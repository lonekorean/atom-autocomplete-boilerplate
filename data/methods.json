[
  {
    "methods": [
      {
        "args": [
          "c",
          "atk"
        ],
        "desc": "Card.IsAttackAbove(c: Card, atk: int)\n\nCheck whether c is more than attack power atk",
        "text": "IsAttackAbove",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetCardTargetCount(c: Card)\n\nReturns the number of current persistent objects",
        "text": "GetCardTargetCount",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetBaseAttack(c: Card)\n\nReturn the original attack power of c",
        "text": "GetBaseAttack",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOriginalType(c: Card)\n\nReturns the type of card entry for c",
        "text": "GetOriginalType",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousRankOnField(c: Card)\n\nReturns the class before the c position changes",
        "text": "GetPreviousRankOnField",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsDisabled(c: Card)\n\nCheck whether c is in an invalid state",
        "text": "IsDisabled",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetBattledGroup(c: Card)\n\nReturns the deck of the card that fought this turn\nFighting has occurred in the calculation of the damage occurred, for the sword and other animals, animal judgments",
        "text": "GetBattledGroup",
        "ret": "Group"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOriginalAttribute(c: Card)\n\nReturns the attributes of the card that c is describing",
        "text": "GetOriginalAttribute",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.CheckFusionMaterial(c: Card [, g: Group, gc: Card | nil, chkf: int = PLAYER_NONE])\n\nCheck if g contains a set of fusion material that c needs [must contain gc]",
        "text": "CheckFusionMaterial",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsChainAttackable(c: Card [, ac: int = 2, monsteronly: boolean = false])\n\nCheck whether c can be a continuous attack, c the number of attacks declared> = ac return false\nNote: This function returns false when c has made multiple attacks due to effects such as flashing swords",
        "text": "IsChainAttackable",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetFusionCode(c: Card)\n\nReturn c as the fusion material when the card number (including the original c card number)",
        "text": "GetFusionCode",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "status"
        ],
        "desc": "Card.IsStatus(c: Card, status: int)\n\nCheck whether c contains a status code",
        "text": "IsStatus",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetTextAttack(c: Card)\n\nReturns the attack power recorded on card c",
        "text": "GetTextAttack",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsReleasable(c: Card)\n\nCheck whether c can be liberated (non-superior call)",
        "text": "IsReleasable",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetReasonEffect(c: Card)\n\nReturns the effect that causes the position of c to change",
        "text": "GetReasonEffect",
        "ret": "Effect"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetBattlePosition(c: Card)\n\nReturns the Battle Position of c before this battle occurs",
        "text": "GetBattlePosition",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetFirstCardTarget(c: Card)\n\nReturns c the current first persistent object",
        "text": "GetFirstCardTarget",
        "ret": "Card"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetEquipGroup(c: Card)\n\nReturns the current set of cards",
        "text": "GetEquipGroup",
        "ret": "Group"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetCardTarget(c: Card)\n\nReturns all currently persistent objects",
        "text": "GetCardTarget",
        "ret": "Group"
      },
      {
        "args": [
          "c",
          "setname"
        ],
        "desc": "Card.IsFusionSetCard(c: Card, setname: int)\n\nCheck the c as a fusion material can be used as a name setname card",
        "text": "IsFusionSetCard",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetRealFieldID(c: Card)\n\nReturns the actual timestamp for the c transition to the current position\nOpening the card from the inside does not change this value",
        "text": "GetRealFieldID",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "reset_code",
          "reset_type"
        ],
        "desc": "Card.ResetEffect(c: Card, reset_code: int, reset_type: int)\n\nTo reset the type to reset_type, reset the type reset_code manual reset c impact of the impact\nThe reset_type can only be one of the following types, and the corresponding reset type is\nRESET_EVENT An event reset_code is set for the event\nRESET_PHASE End of phase Reset the reset_code to phase\nRESET_CODE reset the effect of the specified code reset_code for the type of effect code, can only be reset EFFECT_TYPE_SINGLE sustainable type effect\nRESET_COPY resets the effect of the copy. Reset_code is copy_id\nRESET_CARD The effect of resetting the card reset_code is the card number of the effect owner",
        "text": "ResetEffect",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetLeaveFieldDest(c: Card)\n\nReturns the destination of an effect (such as the universe) that was changed as a result of departure from c",
        "text": "GetLeaveFieldDest",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousControler(c: Card)\n\nReturns the controller before the position change of c",
        "text": "GetPreviousControler",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "location"
        ],
        "desc": "Card.IsLocation(c: Card, location: int)\n\nCheck if c is the current location\nNote: When the monster summon, reverse call, call special summon before the success,\nAnd location = LOCATION_MZONE, this function returns false",
        "text": "IsLocation",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToExtraAsCost(c: Card)\n\nCheck whether c can be sent as an additional cost card group",
        "text": "IsAbleToExtraAsCost",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "g"
        ],
        "desc": "Card.SetMaterial(c: Card, g: Group)\n\nThe g of all the cards as the c material (superior summon, special summon)",
        "text": "SetMaterial",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOwner(c: Card)\n\nReturns the holder of c",
        "text": "GetOwner",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetMaterial(c: Card)\n\nReturns the material used for the appearance of c",
        "text": "GetMaterial",
        "ret": "Group"
      },
      {
        "args": [
          "c",
          "fc"
        ],
        "desc": "Card.CheckFusionSubstitute(c: Card, fc: Card)\n\nCheck whether the c can replace the material description card name of the fusion monster fc",
        "text": "CheckFusionSubstitute",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.ClearEffectRelation(c: Card)\n\nClear all the effects of c contact",
        "text": "ClearEffectRelation",
        "ret": ""
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Card.CancelCardTarget(c1: Card, c2: Card)\n\nCancel c2 as a perpetual object of c1",
        "text": "CancelCardTarget",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOverlayCount(c: Card)\n\nReturns the number of cards currently stacked",
        "text": "GetOverlayCount",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "countertype"
        ],
        "desc": "Card.GetCounter(c: Card, countertype: int)\n\nReturns the number of countertype types on c",
        "text": "GetCounter",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetAttackAncountCount(c: Card)\n\nReturns the number of times this declaration was asserted\nNote: Attack is invalid will not count the number of attacks, but will be counted into the number of attacks on the Declaration",
        "text": "GetAttackAncountCount",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOriginalCode(c: Card)\n\nReturns the code number of the card in c",
        "text": "GetOriginalCode",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetFieldID(c: Card)\n\nReturns the time stamp of the transition to the current position\nThis value is unique, the smaller the c is the earlier appear in that position\nOpening the card from the inside will also change this value",
        "text": "GetFieldID",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.EnableReviveLimit(c: Card)\n\nAdd a limit to the cs for c",
        "text": "EnableReviveLimit",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetCode(c: Card)\n\nReturns the current codename for c (possibly because the effect changes)",
        "text": "GetCode",
        "ret": "int"
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Card.IsRelateToCard(c1: Card, c2: Card)\n\nCheck whether c1 and c2 are linked",
        "text": "IsRelateToCard",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetRank(c: Card)\n\nReturns the current class of c",
        "text": "GetRank",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousLevelOnField(c: Card)\n\nReturns the rank before the c position change",
        "text": "GetPreviousLevelOnField",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "player",
          "min",
          "max",
          "reason"
        ],
        "desc": "Card.RemoveOverlayCard(c: Card, player: int, min: int, max: int, reason: int)\n\nFor reason reason, let players player remove c stacked min-max card, the return value that is successful",
        "text": "RemoveOverlayCard",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOwnerTargetCount(c: Card)\n\nReturns the number of cards that take c as the persistent object",
        "text": "GetOwnerTargetCount",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "e"
        ],
        "desc": "Card.IsRelateToEffect(c: Card, e: Effect)\n\nCheck whether c is associated with effect e\nNote: Each launch into the effect of chain, the effect of launching the card, and the effect of the specified object\n(With Duel.SetTargetCard or Duel.SelectTarget specified, including the take and not take objects)",
        "text": "IsRelateToEffect",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsReleasableByEffect(c: Card)\n\nCheck whether c can be liberated by the effect",
        "text": "IsReleasableByEffect",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "rank"
        ],
        "desc": "Card.IsRankBelow(c: Card, rank: int)\n\nCheck whether c is below the rank rank (at least 1)",
        "text": "IsRankBelow",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsDualState(c: Card)\n\nCheck whether c is in the re-call state",
        "text": "IsDualState",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousDefenseOnField(c: Card)\n\nReturns the defensive power before the c position changes",
        "text": "GetPreviousDefenseOnField",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "e"
        ],
        "desc": "Card.CreateEffectRelation(c: Card, e: Effect)\n\nFor the card c and the effect of e to establish contact",
        "text": "CreateEffectRelation",
        "ret": ""
      },
      {
        "args": [
          "c",
          "xyzc",
          "lv"
        ],
        "desc": "Card.IsXyzLevel(c: Card, xyzc: Card, lv: int)\n\nCheck c for excess monster xyzc with the level of whether the excess is lv",
        "text": "IsXyzLevel",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOverlayGroup(c: Card)\n\nReturns the currently stacked deck",
        "text": "GetOverlayGroup",
        "ret": "Group"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsSSetable(c: Card [, ignore_field: boolean = false])\n\nCheck whether c can be set to the magic trap area, ignore_field = true is disregard of the trap area trap trap",
        "text": "IsSSetable",
        "ret": "boolean"
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Card.CheckEquipTarget(c1: Card, c2: Card)\n\nCheck whether c2 is the correct equipment object for c1",
        "text": "CheckEquipTarget",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "sc"
        ],
        "desc": "Card.GetSynchroLevel(c: Card, sc: Card)\n\nReturn to the co-ordination of c with the call monster sc with the level\nThis function returns the same value as Card.GetLevel (c) except for certain cards such as modems.",
        "text": "GetSynchroLevel",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetTurnID(c: Card)\n\nReturn c The round to the current position",
        "text": "GetTurnID",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "state",
          "enable"
        ],
        "desc": "Card.SetStatus(c: Card, state: int, enable: boolean)\n\nSet or cancel the status code for c\nDo not use this function unless you clearly understand the meaning of each status code",
        "text": "SetStatus",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetReasonCard(c: Card)\n\nReturns the card that caused the position of c to change\nThis function is only valid when a card is destroyed by a battle, because the superior call is released, or becomes a special call to use the material",
        "text": "GetReasonCard",
        "ret": "Card"
      },
      {
        "args": [
          "c",
          "countertype",
          "count"
        ],
        "desc": "Card.IsCanAddCounter(c: Card, countertype: int, count: int [, singly: int = false])\n\nCheck if c can place count counters of type countertype [singly = true]",
        "text": "IsCanAddCounter",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToRemove(c: Card [, player: int])\n\nCheck whether c can be player except player",
        "text": "IsAbleToRemove",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetDestination(c: Card)\n\nReturns the destination of the c position change\nThis function is valid only when processing position transitions instead of effects",
        "text": "GetDestination",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsSummonableCard(c: Card)\n\nCheck whether c is a card that can be called normally",
        "text": "IsSummonableCard",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOriginalCodeRule(c: Card)\n\nReturns the codename on the c rule (used as a card rule on this card)",
        "text": "GetOriginalCodeRule",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousEquipTarget(c: Card)\n\nReturns the device object before c",
        "text": "GetPreviousEquipTarget",
        "ret": "Card"
      },
      {
        "args": [
          "c",
          "e"
        ],
        "desc": "Card.RegisterEffect(c: Card, e: Effect [, forced: boolean = false])\n\nRegister the effect e to c, return the global id of the effect, and set the Handler of e to c\nBy default, if c is registered with the effect of immune e then the registration will fail\nIf forced is true, the immune effect of c against e will not be checked",
        "text": "RegisterEffect",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "neglect_con",
          "neglect_cost",
          "copy_info"
        ],
        "desc": "Card.CheckActivateEffect(c: Card, neglect_con: boolean, neglect_cost: boolean, copy_info: boolean)\n\nReturn to the timing of the launch of the correct c \"card launch\" effect, ignored_con = true ignoring the launch conditions, ignored_cost = true ignoring the launch cost\nCopy_info = false or the free-time effect only returns the effect\nOtherwise return the effect of the time point for the code when the trigger point information eg, ep, ev, re, r, rp",
        "text": "CheckActivateEffect",
        "ret": "Effect"
      },
      {
        "args": [
          "c",
          "attribute",
          "race",
          "level",
          "atk",
          "def"
        ],
        "desc": "Card.AddMonsterAttribute(c: Card, attribute: int, race: int, level: int, atk: int, def: int)\n\nAdd the monster value to the trap card\nNote: Values ​​recorded in the database are treated as the original value, and are set to zero here",
        "text": "AddMonsterAttribute",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousSequence(c: Card)\n\nReturns the sequence number before the c position changes",
        "text": "GetPreviousSequence",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOriginalRightScale(c: Card)\n\nReturns the original right pendulum scale of c",
        "text": "GetOriginalRightScale",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOriginalLeftScale(c: Card)\n\nReturns the original left-hand pendulum scale of c",
        "text": "GetOriginalLeftScale",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "assume_type",
          "assume_value"
        ],
        "desc": "Card.AssumeProperty(c: Card, assume_type: int, assume_value: int)\n\nUse the value of assume_type c as assume_value (genome fighter)\nAssume_type is the following type\nASSUME_CODE card number\nThe ASSUME_TYPE type\nASSUME_LEVEL class\nASSUME_RANK class\nASSUME_ATTRIBUTE property\nASSUME_RACE race\nASSUME_ATTACK Attack power\nASSUME_DEFENSE Defense",
        "text": "AssumeProperty",
        "ret": ""
      },
      {
        "args": [
          "c",
          "check_player"
        ],
        "desc": "Card.CheckUniqueOnField(c: Card, check_player: int)\n\nCheck the uniqueness of c in the check_player field",
        "text": "CheckUniqueOnField",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "s",
          "o",
          "unique_code"
        ],
        "desc": "Card.SetUniqueOnField(c: Card, s: int, o: int, unique_code: int [, unique_location: int = LOCATIOIN_ONFIELD])\n\nSet c to unique_code only in the field [or monster area or magic trap area, determined by the unique_location] can only exist one\nS is not 0 will check the uniqueness of their field, o is not 0 check the other field uniqueness",
        "text": "SetUniqueOnField",
        "ret": ""
      },
      {
        "args": [
          "c",
          "level"
        ],
        "desc": "Card.IsLevelBelow(c: Card, level: int)\n\nCheck whether c is below the level level (at least 1)",
        "text": "IsLevelBelow",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetAttackedCount(c: Card)\n\nReturns the number of times this round has been attacked\nNote: If this value is different from the return value of the previous function, then this card has been a direct attack this round",
        "text": "GetAttackedCount",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "type",
          "value"
        ],
        "desc": "Card.SetHint(c: Card, type: int, value: int)\n\nSet the card prompt for type c to c\nType can only be the following value, the corresponding value type is\nCHINT_TURN Turns\nCHINT_CARD card id\nCHINT_RACE race\nCHINT_ATTRIBUTE property\nCHINT_NUMBER number\nCHINT_DESC Description",
        "text": "SetHint",
        "ret": ""
      },
      {
        "args": [
          "c",
          "e",
          "sumtype",
          "sumplayer",
          "nocheck",
          "nolimit"
        ],
        "desc": "Card.IsCanBeSpecialSummoned(c: Card, e: Effect, sumtype: int, sumplayer: int, nocheck: boolean, nolimit: boolean [, sumpos: int = POS_FACEUP, target_player: int = sumplayer])\n\nCheck whether c can be sumplayer with the effect of the player e to sumtype form sumpos special summon to target_player field\nIf nocheck is true, the call condition of c is not checked, and if nolimit is true, then the limit of c is not checked",
        "text": "IsCanBeSpecialSummoned",
        "ret": "boolean"
      },
      {
        "args": [],
        "desc": "Card.IsDiscardable(Card [, reason: int = REASON_COST])\n\nCheck whether c can be discarded\nNote: This function is only used to detect,\nREASON_DISCARD as a reason to hand a card to the tomb and will not lead to that card can not be discarded",
        "text": "IsDiscardable",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsCanBeRitualMaterial(c: Card [, sc: Card])\n\nCheck whether c can serve as ritual monsters sc sacrifice",
        "text": "IsCanBeRitualMaterial",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetBattleTarget(c: Card)\n\nReturns the card that fought with c",
        "text": "GetBattleTarget",
        "ret": "Card"
      },
      {
        "args": [
          "c",
          "atk"
        ],
        "desc": "Card.IsAttackBelow(c: Card, atk: int)\n\nCheck whether c is attack power atk below (at least 0)",
        "text": "IsAttackBelow",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetTributeRequirement(c: Card)\n\nReturns the minimum and maximum number of sacrifices required to normally call c",
        "text": "GetTributeRequirement",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "player",
          "count",
          "reason"
        ],
        "desc": "Card.CheckRemoveOverlayCard(c: Card, player: int, count: int, reason: int)\n\nCheck the player player can be reason for the reason, at least remove the c stacked count cards",
        "text": "CheckRemoveOverlayCard",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "extra_type"
        ],
        "desc": "Card.TrapMonsterComplete(c: Card, extra_type: int)\n\nSo trap the trap monster c to occupy a magic trap grid, and add the extra_type monster type\nNote: The Trap Monster attribute refers to both the monster and the trap at the same time, and an extra trap that makes a magic trap can not be used",
        "text": "TrapMonsterComplete",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToExtra(c: Card)\n\nCheck if c can send extra cards\nThis function returns false for non-fusion, cohomology, and overdrive cards",
        "text": "IsAbleToExtra",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetControler(c: Card)\n\nReturns the current controller of c",
        "text": "GetControler",
        "ret": "int"
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Card.IsCanBeBattleTarget(c1: Card, c2: Card)\n\nCheck whether c1 can become a target of c2",
        "text": "IsCanBeBattleTarget",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "e"
        ],
        "desc": "Card.IsCanBeEffectTarget(c: Card, e: Effect)\n\nCheck whether c can be the object of effect e",
        "text": "IsCanBeEffectTarget",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetSummonType(c: Card)\n\nReturns the call / special call of c",
        "text": "GetSummonType",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "e"
        ],
        "desc": "Card.IsImmuneToEffect(c: Card, e: Effect)\n\nCheck whether c immune effect e (that is not affected by the impact of e)",
        "text": "IsImmuneToEffect",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.EnableDualState(c: Card)\n\nSet c to re-call state",
        "text": "EnableDualState",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetTurnCounter(c: Card)\n\nReturns the round counter for c",
        "text": "GetTurnCounter",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "sc"
        ],
        "desc": "Card.IsCanBeXyzMaterial(c: Card, sc: Card | nil)\n\nCheck whether c can become an excessive monster sc excess material",
        "text": "IsCanBeXyzMaterial",
        "ret": "boolean"
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Card.IsHasCardTarget(c1: Card, c2: Card)\n\nCheck whether c1 takes c2 as a persistent object",
        "text": "IsHasCardTarget",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetType(c: Card)\n\nReturns the current type of c",
        "text": "GetType",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOriginalLevel(c: Card)\n\nReturns the rank of the card in c",
        "text": "GetOriginalLevel",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToDeckOrExtraAsCost(c: Card)\n\nCheck whether c can be sent as a cost card group or additional card group (for the new Yu-xia, sword fighting beast fusion call monster detection procedures)",
        "text": "IsAbleToDeckOrExtraAsCost",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousCodeOnField(c: Card)\n\nReturns the card number prior to the c position change",
        "text": "GetPreviousCodeOnField",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsCanBeFusionMaterial(c: Card [, fc: Card, ignore_mon: boolean = false])\n\nCheck whether c can become a [fusion monster fc] fusion material, ignore_mon = true does not check whether c is a monster",
        "text": "IsCanBeFusionMaterial",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousTypeOnField(c: Card)\n\nReturns the type before the c position change",
        "text": "GetPreviousTypeOnField",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "level"
        ],
        "desc": "Card.IsLevelAbove(c: Card, level: int)\n\nCheck whether c is above level level",
        "text": "IsLevelAbove",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.EnableUnsummonable(c: Card)\n\nSet c to a monster that can not normally be called",
        "text": "EnableUnsummonable",
        "ret": ""
      },
      {
        "args": [
          "c",
          "setname"
        ],
        "desc": "Card.IsSetCard(c: Card, setname: int)\n\nCheck whether c is a card with the name setname",
        "text": "IsSetCard",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsCanTurnSet(c: Card)\n\nCheck whether c can turn into the inside of that",
        "text": "IsCanTurnSet",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetDefense(c: Card)\n\nReturns the current defense of c, the return value is negative that is \"?\"",
        "text": "GetDefense",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "countertype",
          "count"
        ],
        "desc": "Card.SetCounterLimit(c: Card, countertype: int, count: int)\n\nSet c to place the upper limit of countertype type counters",
        "text": "SetCounterLimit",
        "ret": ""
      },
      {
        "args": [
          "c",
          "countertype"
        ],
        "desc": "Card.EnableCounterPermit(c: Card, countertype: int [, location: int])\n\nAllow c [to be placed in the location location] that can be placed \"can be placed on the counter countertype\nThe default value of location depends on the type of c, and the monster needs to specify whether it can place a pointer in a monster or pendulum area",
        "text": "EnableCounterPermit",
        "ret": ""
      },
      {
        "args": [
          "c",
          "player",
          "countertype",
          "count",
          "reason"
        ],
        "desc": "Card.RemoveCounter(c: Card, player: int, countertype: int, count: int, reason: int)\n\nLet the player player remove count counters of type c on c with reason",
        "text": "RemoveCounter",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetAttribute(c: Card)\n\nReturns the current attribute of c\nNote: For some multi-attribute monsters such as light and dark dragon, the return value of this function may be a combination of several properties of the value",
        "text": "GetAttribute",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsCanBeSynchroMaterial(c: Card [, sc: Card, tuner: Card])\n\nCheck whether c can become a homophonic homophonic monster sc material",
        "text": "IsCanBeSynchroMaterial",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "ignore_count",
          "e"
        ],
        "desc": "Card.IsSummonable(c: Card, ignore_count: boolean, e: Effect | nil [, min: int = 0])\n\nCheck whether c is usually called (not including the normally called set), ignore_count = true does not check the number of calls limit\nE ~ = nil check whether c can be the effect of e is usually called, min said at least the number of sacrifice (used to distinguish between compromise summons and superior call)",
        "text": "IsSummonable",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsForbidden(c: Card)\n\nCheck whether c is in the declaration prohibition state",
        "text": "IsForbidden",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "code",
          "reset_flag",
          "property",
          "reset_count"
        ],
        "desc": "Card.RegisterFlagEffect(c: Card, code: int, reset_flag: int, property: int, reset_count: int [, label: int, desc: int])\n\nFor the registration of a logo with the results\nNote: The effect of the registration to the card is not used for the system,\nEven if the code and the built-in effect code coincidence will not affect,\nAnd the type is always EFFECT_TYPE_SINGLE, reset method, property, and the general effect of the same,\nAnd will not be invalidated, immune effect from the card",
        "text": "RegisterFlagEffect",
        "ret": "Effect"
      },
      {
        "args": [
          "c",
          "attribute"
        ],
        "desc": "Card.IsAttribute(c: Card, attribute: int)\n\nCheck whether c belongs to attribute attribute",
        "text": "IsAttribute",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsPublic(c: Card)\n\nCheck if c is open",
        "text": "IsPublic",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "def"
        ],
        "desc": "Card.IsDefenseAbove(c: Card, def: int)\n\nCheck c is defensive def above",
        "text": "IsDefenseAbove",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetSequence(c: Card)\n\nReturns the serial number of the current position\nIn the field, the sequence number on behalf of the grid, from left to right are 0-4, the venue magic number is 5, left and right pendulum area is 6-7\nIn other places, the serial number represents the first card, the lowest card number is 0",
        "text": "GetSequence",
        "ret": "int"
      },
      {
        "args": [
          "c1",
          "c2",
          "reset_flag"
        ],
        "desc": "Card.CreateRelation(c1: Card, c2: Card, reset_flag: int)\n\nFor c1 established in c2 contact this contact, only because c1 occurred RESET_EVENT the event reset",
        "text": "CreateRelation",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousRaceOnField(c: Card)\n\nReturns the race before the c position changes",
        "text": "GetPreviousRaceOnField",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetReasonPlayer(c: Card)\n\nReturns the player that caused the position of c to change",
        "text": "GetReasonPlayer",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "pos"
        ],
        "desc": "Card.IsPreviousPosition(c: Card, pos: int)\n\nCheck whether the c position before the change is represented by pos",
        "text": "IsPreviousPosition",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsSpecialSummonable(c: Card)\n\nCheck if you can make a special call to c",
        "text": "IsSpecialSummonable",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "def"
        ],
        "desc": "Card.IsDefenseBelow(c: Card, def: int)\n\nCheck whether c is defensive def below (at least 0)",
        "text": "IsDefenseBelow",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "chainc"
        ],
        "desc": "Card.IsRelateToChain(c: Card, chainc: int)\n\nCheck if c is linked to chained chainc\nNote: Each launch into the effect of chain, the effect of launching the card, and the effect of the specified object\n(With Duel.SetTargetCard or Duel.SelectTarget specified, including the take and not take objects)\nWill automatically establish contact with that effect, once the departure, contact will be reset",
        "text": "IsRelateToChain",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOriginalRank(c: Card)\n\nReturns the class of the card in c",
        "text": "GetOriginalRank",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "player",
          "countertype",
          "count",
          "reason"
        ],
        "desc": "Card.IsCanRemoveCounter(c: Card, player: int, countertype: int, count: int, reason: int)\n\nCheck if the player player can remove count counters of type c on c for reason",
        "text": "IsCanRemoveCounter",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "location"
        ],
        "desc": "Card.IsPreviousLocation(c: Card, location: int)\n\nCheck if the location before c is location",
        "text": "IsPreviousLocation",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetEquipTarget(c: Card)\n\nReturns the current artefact object",
        "text": "GetEquipTarget",
        "ret": "Card"
      },
      {
        "args": [
          "c",
          "controler"
        ],
        "desc": "Card.IsControler(c: Card, controler: int)\n\nCheck whether the current control of c is a controler",
        "text": "IsControler",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "pos"
        ],
        "desc": "Card.IsPosition(c: Card, pos: int)\n\nCheck whether c is in the Battle Position pos",
        "text": "IsPosition",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "reason"
        ],
        "desc": "Card.IsReason(c: Card, reason: int)\n\nCheck if c contains the reason",
        "text": "IsReason",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "code"
        ],
        "desc": "Card.ResetFlagEffect(c: Card, code: int)\n\nManually clear the type of c is the code of the identification effect",
        "text": "ResetFlagEffect",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetTextDefense(c: Card)\n\nReturn the c 's card record of the garrison",
        "text": "GetTextDefense",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousPosition(c: Card)\n\nReturns the Battle Position of c before position changes",
        "text": "GetPreviousPosition",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAttackPos(c: Card)\n\nCheck whether c is an attack",
        "text": "IsAttackPos",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousLocation(c: Card)\n\nReturns the position before the c position changes",
        "text": "GetPreviousLocation",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsFaceup(c: Card)\n\nCheck whether c is face-up",
        "text": "IsFaceup",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "e"
        ],
        "desc": "Card.ReleaseEffectRelation(c: Card, e: Effect)\n\nManually release the link between c and effect e",
        "text": "ReleaseEffectRelation",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAttackable(c: Card)\n\nCheck whether c can attack",
        "text": "IsAttackable",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetAttackableTarget(c: Card)\n\nReturns the attackable card set and whether it can attack directly",
        "text": "GetAttackableTarget",
        "ret": "Group"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToRemoveAsCost(c: Card)\n\nCheck whether c can be excluded as a cost",
        "text": "IsAbleToRemoveAsCost",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "code",
          "label"
        ],
        "desc": "Card.SetFlagEffectLabel(c: Card, code: int, label: int)\n\nReturns whether or not c has an identifier of type code, and sets its Label property to label",
        "text": "SetFlagEffectLabel",
        "ret": "boolean"
      },
      {
        "args": [
          "ignore_count",
          "e"
        ],
        "desc": "Card.IsMSetable(Card, ignore_count: boolean, e: Effect | nil [, min: int = 0])\n\nCheck whether c can be normally called set, ignore_count = true does not check the number of calls limit\nE ~ = nil then check whether c can be the effect of e is usually called set, min that at least the number of sacrifices needed (used to distinguish between compromise summoned set and superior summoned set)",
        "text": "IsMSetable",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToGraveAsCost(c: Card)\n\nCheck whether c can be sent to the cemetery as a cost",
        "text": "IsAbleToGraveAsCost",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "code"
        ],
        "desc": "Card.IsHasEffect(c: Card, code: int)\n\nCheck if c is affected by the effect type",
        "text": "IsHasEffect",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToHandAsCost(c: Card)\n\nCheck whether c can be sent as the cost of hand cards\nNote: This function appends the actual destination of c to Card.IsAbleToHand\nThis function returns false when c is sent to the other hand (if the retraction loop is applicable, or c is a blend, cohomology, and oversize)",
        "text": "IsAbleToHandAsCost",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToGrave(c: Card)\n\nCheck whether c can be sent to the cemetery",
        "text": "IsAbleToGrave",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetBattledGroupCount(c: Card)\n\nReturns the number of cards battled for this turn",
        "text": "GetBattledGroupCount",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToHand(c: Card)\n\nCheck whether c can hand\nNote: This function returns false only if the card or player is affected by the effect of being unable to join the hand (such as Ray King)",
        "text": "IsAbleToHand",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToChangeControler(c: Card)\n\nCheck whether c can change the control\nNote: This function returns false only if the card receives the effect of \"Can not change control\"",
        "text": "IsAbleToChangeControler",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "mg"
        ],
        "desc": "Card.IsXyzSummonable(c: Card, mg: Group | nil [, min = 0, max = 0])\n\nCheck whether mg can be selected in the [min-max months] excessive material on the c to call the excess procedure\nIf mg is nil, this function has the same effect as Card.IsSpecialSummonable",
        "text": "IsXyzSummonable",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "tuner"
        ],
        "desc": "Card.IsSynchroSummonable(c: Card, tuner: Card | nil [, mg: Group])\n\nCheck whether tuner can be used as an adjustment, the field card [or mg] for the coherent material on the c cohomology summon procedures\nIf the tuner is nil, this function has the same effect as Card.IsSpecialSummonable",
        "text": "IsSynchroSummonable",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "spsummon_code"
        ],
        "desc": "Card.SetSPSummonOnce(c: Card, spsummon_code: int)\n\nSet c can only be a round of a special call (they reveal, wave dragon)\nThe same spsummon_code shares 1 number of times",
        "text": "SetSPSummonOnce",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.CancelToGrave(c: Card [, cancel: boolean = true])\n\nCancel to send to determine the state tomb, cancel = false to reset the tomb to determine the state\nNote: to send the tomb to determine the state refers to the field to start without leaving field magic and traps, the state of these cards\nCards sent to the tomb determine the state can not return cards and cards, and sent to the cemetery at the end of the chain\nThe purpose of this function is to cancel this state to stay in the field, for the light of the sword and seal the Scarlet Scarlet card",
        "text": "CancelToGrave",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetLeftScale(c: Card)\n\nReturns the left-hand pendulum scale of c",
        "text": "GetLeftScale",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetLevel(c: Card)\n\nReturns the current level of c",
        "text": "GetLevel",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "code",
          "reset_flag"
        ],
        "desc": "Card.ReplaceEffect(c: Card, code: int, reset_flag: int [, reset_count: int])\n\nReplace the effect of c with the effect of the card whose card number is code, and add additional reset conditions\nThe return value is the code id representing the replacement effect",
        "text": "ReplaceEffect",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "code",
          "reset_flag"
        ],
        "desc": "Card.CopyEffect(c: Card, code: int, reset_flag: int [, reset_count: int])\n\nAdding a card number for c is the replicable effect of the card's code, and adding an additional reset condition\nThe return value is the code id representing the copy effect",
        "text": "CopyEffect",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "rc"
        ],
        "desc": "Card.GetRitualLevel(c: Card, rc: Card)\n\nReturns the ritual liberation level for rc ritual monsters\nThis function returns the same value as Card.GetLevel (c) except for certain cards such as ritual objects",
        "text": "GetRitualLevel",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsRelateToBattle(c: Card)\n\nCheck whether c is associated with this battle\nNote: This effect is usually used for damage calculation before the end of the injury phase, used to check whether the fighting off the card too",
        "text": "IsRelateToBattle",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "rank"
        ],
        "desc": "Card.IsRankAbove(c: Card, rank: int)\n\nCheck whether c is above the class rank",
        "text": "IsRankAbove",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "code"
        ],
        "desc": "Card.GetFlagEffectLabel(c: Card, code: int)\n\nThe type of c is the label that identifies the effect of code, and returns nil if it does not",
        "text": "GetFlagEffectLabel",
        "ret": "int"
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Card.ReleaseRelation(c1: Card, c2: Card)\n\nManually release c1 for c2",
        "text": "ReleaseRelation",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsFacedown(c: Card)\n\nCheck whether c is face-down",
        "text": "IsFacedown",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToDeck(c: Card)\n\nCheck whether c can be sent to the card group",
        "text": "IsAbleToDeck",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "code"
        ],
        "desc": "Card.GetEffectCount(c: Card, code: int)\n\nReturns the number of effects that c is affected by the type of code",
        "text": "GetEffectCount",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsAbleToDeckAsCost(c: Card)\n\nCheck whether c can be sent to the card as a cost group",
        "text": "IsAbleToDeckAsCost",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.ResetNegateEffect(c: Card [, code1: int, ...])\n\nReset c affected by the effect of cards whose card number is code1, code2 ...",
        "text": "ResetNegateEffect",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsDirectAttacked(c: Card)\n\nCheck whether c direct attack",
        "text": "IsDirectAttacked",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "countertype",
          "count"
        ],
        "desc": "Card.AddCounter(c: Card, countertype: int, count: int [, singly: int = false])\n\nPlace count count counter type c for c, singly true to add one to the upper limit",
        "text": "AddCounter",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "code"
        ],
        "desc": "Card.IsFusionCode(c: Card, code: int)\n\nCheck the c as a fusion material can be used as the card number for the code card",
        "text": "IsFusionCode",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetSummonPlayer(c: Card)\n\nReturn to Summoner / Special Summoner c Players",
        "text": "GetSummonPlayer",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetUnionCount(c: Card)\n\nReturns the number of ally cards for the current device",
        "text": "GetUnionCount",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetAttackedGroup(c: Card)\n\nReturns the card set attacked by this turn",
        "text": "GetAttackedGroup",
        "ret": "Group"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousAttackOnField(c: Card)\n\nReturns the attack power before the c position changes",
        "text": "GetPreviousAttackOnField",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetEquipCount(c: Card)\n\nReturns the number of cards currently loaded",
        "text": "GetEquipCount",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetLocation(c: Card)\n\nReturns the current position of c",
        "text": "GetLocation",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsControlerCanBeChanged(c: Card)\n\nCheck whether the control of c can be changed\nNote: This function appends the space on the field to the Card.IsAbleToChangeControler",
        "text": "IsControlerCanBeChanged",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetReason(c: Card)\n\nReturns the position change reason for c",
        "text": "GetReason",
        "ret": "int"
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Card.SetCardTarget(c1: Card, c2: Card)\n\nC2 as the perpetual object of c1\nC1 and c2 of the contact will c1 or c2 any one card to leave or become the side of that reset",
        "text": "SetCardTarget",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetAttackedGroupCount(c: Card)\n\nReturns the number of cards that have been attacked this turn",
        "text": "GetAttackedGroupCount",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "code"
        ],
        "desc": "Card.GetFlagEffect(c: Card, code: int)\n\nThe type of returned c is the number of identifying effects of the code",
        "text": "GetFlagEffect",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.ReverseInDeck(c: Card)\n\nThe setting c is indicated in the front of the deck",
        "text": "ReverseInDeck",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOwnerTarget(c: Card)\n\nReturns all cards with c as the persistent object",
        "text": "GetOwnerTarget",
        "ret": "Group"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsDestructable(c: Card [, e: Effect])\n\nCheck whether c is destructible",
        "text": "IsDestructable",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetActivateEffect(c: Card)\n\nReturns the effect of the \"card firing\" of c, that is, the effect of type EFFECT_TYPE_ACTIVATE\nOnly for magic and traps",
        "text": "GetActivateEffect",
        "ret": "Effect"
      },
      {
        "args": [
          "c",
          "setname"
        ],
        "desc": "Card.IsPreviousSetCard(c: Card, setname: int)\n\nCheck whether the name c contains a setname before the c position changes",
        "text": "IsPreviousSetCard",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsOnField(c: Card)\n\nCheck if c is present\nNote: This function returns false when the monster summons, reverses the call, and when the summon is successful",
        "text": "IsOnField",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetMaterialCount(c: Card)\n\nReturns the amount of material used for c appearance",
        "text": "GetMaterialCount",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "counter"
        ],
        "desc": "Card.SetTurnCounter(c: Card, counter: int)\n\nSet c of the round counter (light of the sword, etc.)",
        "text": "SetTurnCounter",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsNotTuner(c: Card)\n\nCheck whether c can be used as a non-adjustment",
        "text": "IsNotTuner",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.IsDefensePos(c: Card)\n\nCheck whether c is in Defense Position",
        "text": "IsDefensePos",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "race"
        ],
        "desc": "Card.IsRace(c: Card, race: int)\n\nCheck if c is race race",
        "text": "IsRace",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "type"
        ],
        "desc": "Card.IsType(c: Card, type: int)\n\nCheck if c is of type type",
        "text": "IsType",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "code1"
        ],
        "desc": "Card.IsCode(c: Card, code1: int [, code2: int, ...])\n\nCheck whether the card number c is code1 [, or code2 ...]",
        "text": "IsCode",
        "ret": "boolean"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetSummonLocation(c: Card)\n\nReturns the call position of c",
        "text": "GetSummonLocation",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPreviousAttributeOnField(c: Card)\n\nReturns the attribute before the c position change",
        "text": "GetPreviousAttributeOnField",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetAttack(c: Card)\n\nReturn the current attack power of c, the return value is a negative that is \"?\"",
        "text": "GetAttack",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetPosition(c: Card)\n\nReturns the current Battle Position of c",
        "text": "GetPosition",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetBaseDefense(c: Card)\n\nReturn to the original c of the defense",
        "text": "GetBaseDefense",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOriginalRace(c: Card)\n\nReturns the c of the card record race",
        "text": "GetOriginalRace",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetRace(c: Card)\n\nReturns the current race of c\nNote: For some multi-ethnic monsters such as animation effects of the magic ape, the function of the return value may be a combination of several racial values",
        "text": "GetRace",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetRightScale(c: Card)\n\nReturns the right-hand pendulum scale of c",
        "text": "GetRightScale",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.GetOverlayTarget(c: Card)\n\nReturns the card with c as the excess material",
        "text": "GetOverlayTarget",
        "ret": "Card"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Card.CompleteProcedure(c: Card)\n\nSo that c to complete the formal call procedures",
        "text": "CompleteProcedure",
        "ret": ""
      }
    ],
    "cls": "Card",
    "hintChar": "c"
  },
  {
    "methods": [
      {
        "args": [
          "e",
          "playerid",
          "s_range",
          "o_range"
        ],
        "desc": "Effect.SetAbsoluteRange(e: Effect, playerid: int, s_range: int, o_range: int)\n\nSet the target range property and set the EFFECT_FLAG_ABSOLUTE_RANGE flag\nPlayerid! = 0 s_range and o_range invert",
        "text": "SetAbsoluteRange",
        "ret": ""
      },
      {
        "args": [
          "e",
          "s_time"
        ],
        "desc": "Effect.SetHintTiming(e: Effect, s_time: int [, o_time: int = s_time])\n\nSet the prompt point",
        "text": "SetHintTiming",
        "ret": ""
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetFieldID(e: Effect)\n\nGets the id of the effect e",
        "text": "GetFieldID",
        "ret": "int"
      },
      {
        "args": [
          "e",
          "cate"
        ],
        "desc": "Effect.SetCategory(e: Effect, cate: int)\n\nSet the Category property",
        "text": "SetCategory",
        "ret": ""
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.Reset(e: Effect)\n\nThe effect of e reset, reset can not be used after this effect",
        "text": "Reset",
        "ret": ""
      },
      {
        "args": [
          "e",
          "prop1"
        ],
        "desc": "Effect.SetProperty(e: Effect, prop1: int [, prop2: int])\n\nSet the Property property",
        "text": "SetProperty",
        "ret": ""
      },
      {
        "args": [
          "e",
          "desc"
        ],
        "desc": "Effect.SetDescription(e: Effect, desc: int)\n\nSets the effect description for effect e",
        "text": "SetDescription",
        "ret": ""
      },
      {
        "args": [
          "e",
          "player"
        ],
        "desc": "Effect.IsActivatable(e: Effect, player: int)\n\nCheck whether the effect can be launched by the player",
        "text": "IsActivatable",
        "ret": "boolean"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetCategory(e: Effect)\n\nReturns the Category property",
        "text": "GetCategory",
        "ret": "int"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetType(e: Effect)\n\nReturns the Type property",
        "text": "GetType",
        "ret": "int"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.SetOwnerPlayer(e: Effect [, player: int])\n\nSet the OwnerPlayer property to player",
        "text": "SetOwnerPlayer",
        "ret": ""
      },
      {
        "args": [
          "e",
          "code"
        ],
        "desc": "Effect.SetCode(e: Effect, code: int)\n\nSet the Code property for effect e",
        "text": "SetCode",
        "ret": ""
      },
      {
        "args": [
          "e",
          "range"
        ],
        "desc": "Effect.SetRange(e: Effect, range: int)\n\nSet the Range property for effect e",
        "text": "SetRange",
        "ret": ""
      },
      {
        "args": [
          "e",
          "type"
        ],
        "desc": "Effect.SetType(e: Effect, type: int)\n\nSet the Type property for effect e",
        "text": "SetType",
        "ret": ""
      },
      {
        "args": [
          "e",
          "reset_flag"
        ],
        "desc": "Effect.SetReset(e: Effect, reset_flag: int [, reset_count: int = 1])\n\nSet the reset parameter",
        "text": "SetReset",
        "ret": ""
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetActivateLocation(e: Effect)\n\nReturns the firing area of ​​the effect e",
        "text": "GetActivateLocation",
        "ret": "int"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.IsActivated(e: Effect)\n\nCheck the effect of e is the effect of starting (chassis)",
        "text": "IsActivated",
        "ret": "boolean"
      },
      {
        "args": [
          "e",
          "type"
        ],
        "desc": "Effect.IsHasType(e: Effect, type: int)\n\nCheck if the effect is of type `type`",
        "text": "IsHasType",
        "ret": "boolean"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetValue(e: Effect)\n\nReturns the value attribute",
        "text": "GetValue",
        "ret": "function"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.Clone(e: Effect)\n\nCreate a new copy of effect e",
        "text": "Clone",
        "ret": "Effect"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetHandler(e: Effect)\n\nReturns the card on which the effect takes effect (usually a card that registers the effect with Card.RegisterEffect)",
        "text": "GetHandler",
        "ret": "Card"
      },
      {
        "args": [
          "e",
          "cate"
        ],
        "desc": "Effect.IsHasCategory(e: Effect, cate: int)\n\nCheck whether the effect contains cate",
        "text": "IsHasCategory",
        "ret": "boolean"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetActiveType(e: Effect)\n\nReturns the effect type of e (monster, magic, trap)\nAnd launch the effect of the type of card is not necessarily the same, such as the spirit of pendulum effect as a magic card effect",
        "text": "GetActiveType",
        "ret": "int"
      },
      {
        "args": [
          "e",
          "prop1"
        ],
        "desc": "Effect.IsHasProperty(e: Effect, prop1: int [, prop2: int])\n\nCheck if the effect contains the flags prop1 [and prop2]",
        "text": "IsHasProperty",
        "ret": "boolean"
      },
      {
        "args": [
          "e",
          "cost_func"
        ],
        "desc": "Effect.SetCost(e: Effect, cost_func: function)\n\nSet the Cost property",
        "text": "SetCost",
        "ret": ""
      },
      {
        "args": [
          "e",
          "type"
        ],
        "desc": "Effect.IsActiveType(e: Effect, type: int)\n\nCheck if the effect type of e (monster, magic, trap) has a type",
        "text": "IsActiveType",
        "ret": "boolean"
      },
      {
        "args": [],
        "desc": "Effect.GlobalEffect()\n\nCreate a new global effect",
        "text": "GlobalEffect",
        "ret": "Effect"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetOwnerPlayer(e: Effect)\n\nReturns the OwnerPlayer property, which is typically the controller of the Owner",
        "text": "GetOwnerPlayer",
        "ret": "int"
      },
      {
        "args": [
          "e",
          "con_func"
        ],
        "desc": "Effect.SetCondition(e: Effect, con_func: function)\n\nSet the Condition property",
        "text": "SetCondition",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Effect.CreateEffect(c: Card)\n\nCreate a new empty effect\nAnd the owner of the effect is c",
        "text": "CreateEffect",
        "ret": "Effect"
      },
      {
        "args": [
          "e",
          "val"
        ],
        "desc": "Effect.SetValue(e: Effect, val: function | int | boolean)\n\nSet the Value property",
        "text": "SetValue",
        "ret": ""
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetOperation(e: Effect)\n\nReturns the operation attribute",
        "text": "GetOperation",
        "ret": "function"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetCost(e: Effect)\n\nReturns the cost attribute",
        "text": "GetCost",
        "ret": "function"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetHandlerPlayer(e: Effect)\n\nReturn to the current, usually Handle controller",
        "text": "GetHandlerPlayer",
        "ret": "int"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetCondition(e: Effect)\n\nReturns the condition property",
        "text": "GetCondition",
        "ret": "function"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetLabel(e: Effect)\n\nReturns the Label property",
        "text": "GetLabel",
        "ret": "int"
      },
      {
        "args": [
          "e",
          "op_func"
        ],
        "desc": "Effect.SetOperation(e: Effect, op_func: function)\n\nSet the Operation property",
        "text": "SetOperation",
        "ret": ""
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetLabelObject(e: Effect)\n\nReturns the LabelObject property",
        "text": "GetLabelObject",
        "ret": "Card"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetOwner(e: Effect)\n\nReturns the Owner property",
        "text": "GetOwner",
        "ret": "Card"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetTarget(e: Effect)\n\nReturns the target attribute",
        "text": "GetTarget",
        "ret": "function"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetCode(e: Effect)\n\nReturns the code property",
        "text": "GetCode",
        "ret": "int"
      },
      {
        "args": [
          "e",
          "labelobject"
        ],
        "desc": "Effect.SetLabelObject(e: Effect, labelobject: Card | Group | Effect)\n\nSets the LabelObject property",
        "text": "SetLabelObject",
        "ret": ""
      },
      {
        "args": [
          "e",
          "s_range",
          "o_range"
        ],
        "desc": "Effect.SetTargetRange(e: Effect, s_range: int, o_range: int)\n\nSet the Target Range property for effect e\nS_range refers to our area of ​​influence\nThe o_range value affects the partner area\nIf the EFFECT_FLAG_ABSOLUTE_RANGE flag is specified in the property property,\nThen s_range refers to the player 1 affected area, o_range refers to player 2 affected area\nIf this is a call (cover) / limit call (cover) / special call procedure\n(EFFECT_SUMMON_PROC / EFFECT_LIMIT_SUMMON_PROC / EFFECT_SPSUMMON_PROC, etc.)\nAnd the property specifies the EFFECT_FLAG_SPSUM_PARAM flag,\nThen s_range that special summoned to the players of the venue,\nO_range represents a selectable representation",
        "text": "SetTargetRange",
        "ret": ""
      },
      {
        "args": [
          "e",
          "targ_func"
        ],
        "desc": "Effect.SetTarget(e: Effect, targ_func: function)\n\nSet the Target property",
        "text": "SetTarget",
        "ret": ""
      },
      {
        "args": [
          "e",
          "count"
        ],
        "desc": "Effect.SetCountLimit(e: Effect, count: int [, code: int = 0])\n\nSet the number of times a round can be launched count (only trigger type effect is valid), the same code (not equal to 0 or 1) share a number of times\nThe code contains the following values ​​that have special properties\nEFFECT_COUNT_CODE_OATH The number of vows\nEFFECT_COUNT_CODE_DUEL The number of times in the duel\nEFFECT_COUNT_CODE_SINGLE the same card more than the number of public use of the effect (not the same name card)",
        "text": "SetCountLimit",
        "ret": ""
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetProperty(e: Effect)\n\nReturns the Property property",
        "text": "GetProperty",
        "ret": "int"
      },
      {
        "args": [
          "e"
        ],
        "desc": "Effect.GetDescription(e: Effect)\n\nReturns the description of the effect",
        "text": "GetDescription",
        "ret": "int"
      },
      {
        "args": [
          "e",
          "label"
        ],
        "desc": "Effect.SetLabel(e: Effect, label: int)\n\nSets the Label property",
        "text": "SetLabel",
        "ret": ""
      }
    ],
    "cls": "Effect",
    "hintChar": "e"
  },
  {
    "methods": [
      {
        "args": [
          "g",
          "f"
        ],
        "desc": "Group.GetSum(g: Group, f: function, ...)\n\nCalculates the sum of the values ​​of all cards in g, f is the value function for each card, starting with the third parameter as an additional parameter",
        "text": "GetSum",
        "ret": "int"
      },
      {
        "args": [
          "g",
          "f",
          "ex"
        ],
        "desc": "Group.Filter(g: Group, f: function, ex: Card | nil, ...)\n\nThe filter function filters the card from g that satisfies the filter condition f and is not equal to ex\nStarting from the 4th parameter as an additional parameter",
        "text": "Filter",
        "ret": "Group"
      },
      {
        "args": [
          "g",
          "f"
        ],
        "desc": "Group.GetMinGroup(g: Group, f: function, ...)\n\nF is a function that returns an interger value, and the card with the smallest value of f is selected from g\nThe second return value is the minimum value, starting at the third parameter as an additional parameter\nTo use the second return value Note Check g is not empty",
        "text": "GetMinGroup",
        "ret": "Group"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Group.Clone(g: Group)\n\nCreate a new copy of card group g",
        "text": "Clone",
        "ret": "Group"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Group.KeepAlive(g: Group)\n\nLet the deck continue, set the deck to effect LabelObject needs to be set",
        "text": "KeepAlive",
        "ret": ""
      },
      {
        "args": [
          "g",
          "player",
          "f",
          "min",
          "max",
          "ex"
        ],
        "desc": "Group.FilterSelect(g: Group, player: int, f: function, min: int, max: int, ex: Card | nil, ...)\n\nFilter function, allowing players to choose from the g player min-max sheets meet the screening conditions f and not equal to the ex card\nStarting with the 7th argument is an additional parameter",
        "text": "FilterSelect",
        "ret": "Group"
      },
      {
        "args": [
          "g",
          "f",
          "ex"
        ],
        "desc": "Group.Remove(g: Group, f: function, ex: Card | nil, ...)\n\nRemove all cards from g that satisfy the filter condition f and not equal to ex, the fourth parameter starts with the extra argument",
        "text": "Remove",
        "ret": ""
      },
      {
        "args": [
          "g",
          "player",
          "f",
          "sum"
        ],
        "desc": "Group.SelectWithSumGreater(g: Group, player: int, f: function, sum: int, ...)\n\nLet the player player select a subset from g so that the sum of the particular function f of the subset is greater than or equal to sum, starting at the fifth argument as an extra parameter",
        "text": "SelectWithSumGreater",
        "ret": "Group"
      },
      {
        "args": [
          "g",
          "f",
          "count",
          "ex"
        ],
        "desc": "Group.IsExists(g: Group, f: function, count: int, ex: Card | nil, ...)\n\nFilter function to check if there is at least count of cards in g that satisfy the filter condition f and not equal to ex\nStarting from the 5th parameter as an additional parameter",
        "text": "IsExists",
        "ret": "boolean"
      },
      {
        "args": [
          "g1",
          "g2"
        ],
        "desc": "Group.Merge(g1: Group, g2: Group)\n\nCombine all cards in g2 to g1\nNote: g2 itself does not change",
        "text": "Merge",
        "ret": ""
      },
      {
        "args": [
          "g1",
          "g2"
        ],
        "desc": "Group.Equal(g1: Group, g2: Group)\n\nIt is judged whether or not g1 and g2 are the same",
        "text": "Equal",
        "ret": "boolean"
      },
      {
        "args": [
          "g",
          "player",
          "count"
        ],
        "desc": "Group.RandomSelect(g: Group, player: int, count: int)\n\nLet the player player randomly select count cards from g\nBecause it is a random choice, so the basic parameter useless player, randomly selected by the system",
        "text": "RandomSelect",
        "ret": "Group"
      },
      {
        "args": [
          "g",
          "f"
        ],
        "desc": "Group.GetClassCount(g: Group, f: function, ...)\n\nCalculate the number of all cards in g, f is the basis of the classification, return the same value as the same category, starting from the first three parameters for additional parameters",
        "text": "GetClassCount",
        "ret": "int"
      },
      {
        "args": [
          "g",
          "f"
        ],
        "desc": "Group.SearchCard(g: Group, f: function, ...)\n\nReturns the first card in g that satisfies the filter condition f, starting at the third argument as an extra argument",
        "text": "SearchCard",
        "ret": "Card"
      },
      {
        "args": [
          "g",
          "f"
        ],
        "desc": "Group.GetMaxGroup(g: Group, f: function, ...)\n\nF is the function that returns an interger value, and the card with the largest value of f is selected from g\nThe second return value is the maximum value, starting with the third parameter as an additional parameter\nTo use the second return value Note Check g is not empty",
        "text": "GetMaxGroup",
        "ret": "Group"
      },
      {
        "args": [
          "g",
          "player",
          "min",
          "max",
          "ex"
        ],
        "desc": "Group.Select(g: Group, player: int, min: int, max: int, ex: Card | nil)\n\nLet player player from g select the min-max Zhang is not equal to the ex card",
        "text": "Select",
        "ret": "Group"
      },
      {
        "args": [],
        "desc": "Group.CreateGroup()\n\nCreates an empty group of cards",
        "text": "CreateGroup",
        "ret": "Group"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Group.GetCount(g: Group)\n\nReturns the number of cards in g",
        "text": "GetCount",
        "ret": "int"
      },
      {
        "args": [
          "g",
          "f",
          "ex"
        ],
        "desc": "Group.FilterCount(g: Group, f: function, ex: Card | nil, ...)\n\nFilter function, and Group.Filter is basically the same, the difference is that this function only returns the number of cards to meet the conditions",
        "text": "FilterCount",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Group.FromCards(c: Card [, ...])\n\nIndefinite parameters, the incoming card into a combination of all cards and return",
        "text": "FromCards",
        "ret": "Group"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Group.GetFirst(g: Group)\n\nReturns the first card in g and resets the current pointer to the first card in g\nReturns nil if card does not exist in g",
        "text": "GetFirst",
        "ret": "Card"
      },
      {
        "args": [
          "g",
          "c"
        ],
        "desc": "Group.IsContains(g: Group, c: Card)\n\nCheck g for card c",
        "text": "IsContains",
        "ret": "boolean"
      },
      {
        "args": [
          "g",
          "f",
          "sum",
          "min",
          "max"
        ],
        "desc": "Group.CheckWithSumEqual(g: Group, f: function, sum: int, min: int, max: int, ...)\n\nThe subset summation decision function, f, is a function that returns an interger value\nCheck whether there is a subset of min-max in g that satisfies that the sum of the values ​​of each element of the subset f is equal to sum, starting at the 6th argument as an extra parameter\nFor example: g: CheckWithSumEqual (Card.GetSynchroLevel, 7,2,99)\nCheck if the sum of the same call levels in a subset of g satisfies a subset equal to 7",
        "text": "CheckWithSumEqual",
        "ret": "boolean"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Group.GetNext(g: Group)\n\nPoint the pointer to the next card and return the card, or nil if it does not exist",
        "text": "GetNext",
        "ret": "Card"
      },
      {
        "args": [
          "g1",
          "g2"
        ],
        "desc": "Group.Sub(g1: Group, g2: Group)\n\nRemove the card from g1 that belongs to g2\nNote: g2 itself does not change",
        "text": "Sub",
        "ret": ""
      },
      {
        "args": [
          "g",
          "f",
          "sum"
        ],
        "desc": "Group.CheckWithSumGreater(g: Group, f: function, sum: int, ...)\n\nThe sum of the subsets is determined by a function f, which is a function that returns an interger value\nCheck that there is a subset in g that satisfies that the sum of the values ​​of each element of the subset f is just greater than or equal to sum, starting at the fourth argument as an extra parameter\nFor example: g: CheckWithSumGreater (Card.GetRitualLevel, 8)\nCheck if the sum of the ritual classes in g satisfies a subset of 8 or greater\nNote: The decision must be \"just\" greater than or equal to\nTo grade, for example, to make the total level is greater than or equal to 8, you can choose LV1 + LV7 and can not choose LV1 + LV4 + LV4",
        "text": "CheckWithSumGreater",
        "ret": "boolean"
      },
      {
        "args": [
          "g",
          "c"
        ],
        "desc": "Group.AddCard(g: Group, c: Card)\n\nAdd card c to group g",
        "text": "AddCard",
        "ret": ""
      },
      {
        "args": [
          "g",
          "f"
        ],
        "desc": "Group.ForEach(g: Group, f: function)\n\nCall f once for each card in g as a parameter",
        "text": "ForEach",
        "ret": ""
      },
      {
        "args": [
          "g",
          "player",
          "f",
          "sum",
          "min",
          "max"
        ],
        "desc": "Group.SelectWithSumEqual(g: Group, player: int, f: function, sum: int, min: int, max: int, ...)\n\nLet the player player select a subset of min-max from g so that the sum of the specific functions of the subset is equal to sum, starting at the 7th argument as an extra parameter",
        "text": "SelectWithSumEqual",
        "ret": "Group"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Group.DeleteGroup(g: Group)\n\nDelete the card group g",
        "text": "DeleteGroup",
        "ret": ""
      },
      {
        "args": [
          "g",
          "c"
        ],
        "desc": "Group.RemoveCard(g: Group, c: Card)\n\nRemove card c from group g",
        "text": "RemoveCard",
        "ret": ""
      },
      {
        "args": [
          "g"
        ],
        "desc": "Group.Clear(g: Group)\n\nEmpty the deck",
        "text": "Clear",
        "ret": ""
      }
    ],
    "cls": "Group",
    "hintChar": "g"
  },
  {
    "methods": [
      {
        "args": [
          "equip_card",
          "target"
        ],
        "desc": "Debug.PreEquip(equip_card: Card, target: Card)\n\nAdd equip_card to the target",
        "text": "PreEquip",
        "ret": "boolean"
      },
      {
        "args": [
          "msg"
        ],
        "desc": "Debug.ShowHint(msg: string)\n\nA message box appears",
        "text": "ShowHint",
        "ret": ""
      },
      {
        "args": [
          "msg"
        ],
        "desc": "Debug.Message(msg: any)\n\nDisplays the message",
        "text": "Message",
        "ret": ""
      },
      {
        "args": [
          "c",
          "sum_type"
        ],
        "desc": "Debug.PreSummon(c: Card, sum_type: int [, sum_location: int = 0])\n\nSet summon information for card c: Summarize with sum_type method (usually summoned, special summoned, etc.) [from sum_location]",
        "text": "PreSummon",
        "ret": ""
      },
      {
        "args": [
          "c",
          "counter_type",
          "count"
        ],
        "desc": "Debug.PreAddCounter(c: Card, counter_type: int, count: int)\n\nAdd count counters_type counters for c",
        "text": "PreAddCounter",
        "ret": ""
      },
      {
        "args": [
          "code",
          "owner",
          "player",
          "location",
          "seq",
          "pos"
        ],
        "desc": "Debug.AddCard(code: int, owner: int, player: int, location: int, seq: int, pos: int [, proc: boolean = false])\n\nAdd a card, the card number for the card holder is set to owner, to represent the form of pos placed in the player's field is located in the location on the seq seq grid\nProc = true then lifted the Soviet students limit",
        "text": "AddCard",
        "ret": "Card"
      },
      {
        "args": [
          "flag"
        ],
        "desc": "Debug.ReloadFieldBegin(flag: int)\n\nStart with the option flag\nFlag: DUEL_ATTACK_FIRST_TURN + DUEL_SIMPLE_AI",
        "text": "ReloadFieldBegin",
        "ret": ""
      },
      {
        "args": [
          "playerid",
          "lp",
          "startcount",
          "drawcount"
        ],
        "desc": "Debug.SetPlayerInfo(playerid: int, lp: int, startcount: int, drawcount: int)\n\nSet the player information, divided into lp, the initial hand card for the startcount Zhang, drawcount each round of pumping\nPlayerid below 0, top 1",
        "text": "SetPlayerInfo",
        "ret": ""
      },
      {
        "args": [
          "name"
        ],
        "desc": "Debug.SetAIName(name: string)\n\nSet the name of the AI",
        "text": "SetAIName",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Debug.ReloadFieldEnd()\n\nLayout ends",
        "text": "ReloadFieldEnd",
        "ret": ""
      },
      {
        "args": [
          "c",
          "target"
        ],
        "desc": "Debug.PreSetTarget(c: Card, target: Card)\n\nThe target selected as the perpetual object c",
        "text": "PreSetTarget",
        "ret": ""
      }
    ],
    "cls": "Debug"
  },
  {
    "methods": [
      {
        "args": [
          "code"
        ],
        "desc": "Duel.IsEnvironment(code: int [, player: int = PLAYER_ALL])\n\nCheck whether the player player is the source code of the venue code\nThe site code refers to the code of the venue card in effect, or the value of the effect of the venue change\nSource Player is the controller of the card in effect, or the controller of the Poseidon Witch, etc.",
        "text": "IsEnvironment",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "c",
          "f",
          "lv",
          "min",
          "max"
        ],
        "desc": "Duel.SelectXyzMaterial(player: int, c: Card, f: function, lv: int, min: int, max: int [, mg: Group])\n\nLet the player player for the excess monster c [from the mg] to select the excess with the level of lv for the min-max meet the conditions of the stack f material",
        "text": "SelectXyzMaterial",
        "ret": "Group"
      },
      {
        "args": [],
        "desc": "Duel.IsDamageCalculated()\n\nUsed to check if damage has been calculated during the damage phase",
        "text": "IsDamageCalculated",
        "ret": "boolean"
      },
      {
        "args": [
          "chainc",
          "f"
        ],
        "desc": "Duel.ChangeChainOperation(chainc: int, f: function)\n\nThe effect of the chain chainc processing function replaced by f, used to achieve \"the effect becomes\" effect",
        "text": "ChangeChainOperation",
        "ret": ""
      },
      {
        "args": [
          "f",
          "player",
          "s",
          "o",
          "count",
          "ex"
        ],
        "desc": "Duel.IsExistingTarget(f: function, player: int, s: int, o: int, count: int, ex: Card | nil, ...)\n\nFilter function to check whether there is at least the specified number of positions to meet the filter conditions f and not equal ex\nAnd can become a card of an object that is currently being processed\nThe seventh argument starts as an extra parameter",
        "text": "IsExistingTarget",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "phase",
          "reset_flag",
          "reset_count"
        ],
        "desc": "Duel.SkipPhase(player: int, phase: int, reset_flag: int, reset_count: int [, value: int])\n\nSkip player phase phase player, and in a specific stage after reset, reset parameters and the same effect",
        "text": "SkipPhase",
        "ret": ""
      },
      {
        "args": [
          "f"
        ],
        "desc": "Duel.SetChainLimitTillChainEnd(f: function)\n\nFunction with Duel.SetChainLimit, but this function sets the chain until the end of the chain will be lifted",
        "text": "SetChainLimitTillChainEnd",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.CheckChainUniqueness()\n\nCheck the existence of the current chain of the same name card launch, true that no card with the same name",
        "text": "CheckChainUniqueness",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "desc"
        ],
        "desc": "Duel.SelectYesNo(player: int, desc: int)\n\nLet player player select Yes or No",
        "text": "SelectYesNo",
        "ret": "boolean"
      },
      {
        "args": [
          "sel_player",
          "f",
          "player",
          "s",
          "o",
          "min",
          "max",
          "ex"
        ],
        "desc": "Duel.SelectTarget(sel_player: int, f: function, player: int, s: int, o: int, min: int, max: int, ex: Card | nil, ...)\n\nFilter function, so that player sel_player select the specified location to meet the filter condition f and not equal ex\nAnd can be the min-max card of the object that is currently processing the effect\nThe ninth parameter starts as an extra parameter\nThis function sets the currently locked object to the selected card at the same time",
        "text": "SelectTarget",
        "ret": "Group"
      },
      {
        "args": [
          "hint_type",
          "player",
          "desc"
        ],
        "desc": "Duel.Hint(hint_type: int, player: int, desc: int)\n\nSend hint_type to the player player type of message prompts, the contents of the prompt desc",
        "text": "Hint",
        "ret": ""
      },
      {
        "args": [
          "c",
          "f1",
          "f2",
          "min",
          "max"
        ],
        "desc": "Duel.CheckSynchroMaterial(c: Card, f1: function, f2: function, min: int, max: int [, smat: Card, mg: Group])\n\nCheck [mg] whether there is a group [must include smat] meet the conditions of the min-max cards as cohort calls c material\nF1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions",
        "text": "CheckSynchroMaterial",
        "ret": "boolean"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Duel.ShuffleSetCard(g: Group)\n\nCut the card (magic hat) over the monster area",
        "text": "ShuffleSetCard",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.AdjustInstantly([c: Card])\n\nManually refreshing the card's inactive state on card [affected by card c]",
        "text": "AdjustInstantly",
        "ret": ""
      },
      {
        "args": [
          "player",
          "c",
          "mg"
        ],
        "desc": "Duel.XyzSummon(player: int, c: Card, mg: Group | nil [, min = 0, max = 0])\n\nLet the player player [from the mg] [choose min-max a material] on the c to call the excess procedure\nMg is not empty and min is 0 mg directly to all the excess material",
        "text": "XyzSummon",
        "ret": ""
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Duel.MajesticCopy(c1: Card, c2: Card)\n\nSalvation Star Dragon dedicated. Copy the effect described in c2 to c1\nForced to launch the effect can choose whether to launch",
        "text": "MajesticCopy",
        "ret": ""
      },
      {
        "args": [
          "sel_player",
          "f",
          "min",
          "max",
          "ex"
        ],
        "desc": "Duel.SelectReleaseGroup(sel_player: int, f: function, min: int, max: int, ex: Card | nil, ...)\n\nFilter function, allowing players to choose from the field min-max Zhang is not equal to ex to meet the conditions f can be liberated card (non-superior summon)",
        "text": "SelectReleaseGroup",
        "ret": "Group"
      },
      {
        "args": [
          "chainc",
          "category"
        ],
        "desc": "Duel.GetOperationInfo(chainc: int, category: int)\n\nReturns the operation information of the chained chainc category, with a return value of 5,\nThe first return value is false to indicate that the class does not exist\nThe last four return values ​​correspond to the last four parameters of Duel.SetOperationInfo: Card | Group targets, int count, int target_player, int target_param",
        "text": "GetOperationInfo",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "c",
          "g"
        ],
        "desc": "Duel.SelectFusionMaterial(player: int, c: Card, g: Group [, gc: Card | nil, chkf: int = PLAYER_NONE])\n\nLet the player player from the g to select a group [must contain gc] fusion fusion monster c material",
        "text": "SelectFusionMaterial",
        "ret": "Group"
      },
      {
        "args": [
          "global_flag"
        ],
        "desc": "Duel.EnableGlobalFlag(global_flag: int)\n\nSet the global flag global_flag",
        "text": "EnableGlobalFlag",
        "ret": ""
      },
      {
        "args": [
          "player",
          "code"
        ],
        "desc": "Duel.CreateToken(player: int, code: int [, setcode: int, attack: int, defense: inte, level: int, race: int, attribute: int])\n\nCreates a new Token with the passed in parameter value and returns",
        "text": "CreateToken",
        "ret": "Card"
      },
      {
        "args": [
          "targets",
          "player",
          "seq",
          "reason"
        ],
        "desc": "Duel.SendtoDeck(targets: Card | Group, player: int | nil, seq: int, reason: int)\n\nThe reason for the targets sent to the players player card group, the return value is the actual number of operations\nIf player is nil, the card holder of the card is returned\nIf seq = 0, it is the top of the returned card group; seq = 1 is the bottom of the returned card group;\nThe rest of the case is to return to the top and mark the need to wash the card group.",
        "text": "SendtoDeck",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "targets"
        ],
        "desc": "Duel.ConfirmCards(player: int, targets: Card | Group)\n\nIdentify targets for the player",
        "text": "ConfirmCards",
        "ret": ""
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.IsPlayerCanSummon(player: int [, sumtype: int, c: Card])\n\nCheck player player can usually call [c, to sumtype]\nIf optional parameters are required, they must all be used\nReturns false only if the player receives an effect such as \"can not summon a superordinate\"",
        "text": "IsPlayerCanSummon",
        "ret": "boolean"
      },
      {
        "args": [],
        "desc": "Duel.DisableShuffleCheck([disable = true])\n\nSo that the next operation does not check for the need for a wash card set or a hand card\nNote: If you do not call this function,\nIn addition to calling Duel.DiscardDeck and Duel.Draw remove the card from the card group or add the card to the card\nOr the card is added to the deck (not the top or bottom), the system automatically cleans the card group or the hand card at the end of the effect process\nIf you do not want to do so, for example, from the top of the card group, except for a card and other operations, you need to call this function\nThis function only ensures that no subsequent scrub detection is performed in the next operation",
        "text": "DisableShuffleCheck",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.RDComplete()\n\nIn the call Duel.Damage / Duel.Recover, if is_step parameter is true, you need to call this function when the trigger point",
        "text": "RDComplete",
        "ret": ""
      },
      {
        "args": [
          "player",
          "cost"
        ],
        "desc": "Duel.CheckLPCost(player: int, cost: int)\n\nCheck player player can pay cost point lp",
        "text": "CheckLPCost",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "desc1"
        ],
        "desc": "Duel.SelectOption(player: int, desc1: int, ...)\n\nLet the player select the option, starting with the second argument, where each parameter represents an option\nReturns the serial number of the selected option (0-based)",
        "text": "SelectOption",
        "ret": "int"
      },
      {
        "args": [
          "f",
          "player",
          "s",
          "o",
          "ex"
        ],
        "desc": "Duel.GetFirstMatchingCard(f: function, player: int, s: int, o: int, ex: Card | nil, ...)\n\nFilter function to return to the specified location to meet the filter condition f and not equal to the first card ex.\nThe sixth parameter starts as an extra parameter.",
        "text": "GetFirstMatchingCard",
        "ret": "Card"
      },
      {
        "args": [
          "counter_id",
          "activity_type",
          "f"
        ],
        "desc": "Duel.AddCustomActivityCounter(counter_id: int, activity_type: int, f: function)\n\nSet the action type to activity_type, code counter_id counter, placed in the initial_effect function\nF for the filter function, the card type parameters, the return value of false cards for the following types of operations, the counter increased by 1 (at present up to 1)\nThe activity_type is of the following type\nACTIVITY_SUMMON call (not including the usual call set)\nACTIVITY_NORMALSUMMON usually called (including the usual call set)\nACTIVITY_SPSUMMON Special call\nACTIVITY_FLIPSUMMON Reverse call\nACTIVITY_CHAIN ​​Activates the effect",
        "text": "AddCustomActivityCounter",
        "ret": ""
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.GetBattledCount(player: int)\n\nReturns the number of times a player fought this turn",
        "text": "GetBattledCount",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Duel.ReplaceAttacker(c: Card)\n\n",
        "text": "ReplaceAttacker",
        "ret": ""
      },
      {
        "args": [
          "targets",
          "player",
          "reason"
        ],
        "desc": "Duel.SendtoExtraP(targets: Card | Group, player: int | nil, reason: int)\n\nThe reason for the reason the spirit of the swing card targets sent to the player player extra card group, the return value is the actual number of operations\nIf player is nil, it returns the extra card group for the card holder.",
        "text": "SendtoExtraP",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "s",
          "o",
          "countertype"
        ],
        "desc": "Duel.GetCounter(player: int, s: int, o: int, countertype: int)\n\nReturns the number of counterstype types that exist on the farm\nS represents the position of the player's own removable pointer, o represents the position of the opponent's removable pointer for the player.",
        "text": "GetCounter",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "number"
        ],
        "desc": "Duel.AnnounceNumber(player: int, number: int, ...)\n\nLet the player player declare a number\nStarting with the second argument, each parameter represents a declarable number\nThe first return value is the number of declarations, and the second return value is the declaration number of the position in all options",
        "text": "AnnounceNumber",
        "ret": "int"
      },
      {
        "args": [
          "chainc"
        ],
        "desc": "Duel.GetChainInfo(chainc: int, ...)\n\nReturns the chainc information, if chainc = 0, returns the chain of information currently being processed\nThis function returns the corresponding number of return values ​​in sequence according to the number of arguments passed in. The arguments can be:\nCHAININFO_CHAIN_COUNT The serial number of the chain\nCHAININFO_TRIGGERING_EFFECT The effect of the chain\nCHAININFO_TRIGGERING_PLAYER\nCHAININFO_TRIGGERING_CONTROLER The player to which the chained position belongs\nCHAININFO_TRIGGERING_LOCATION The location where the chain occurred\nCHAININFO_TRIGGERING_SEQUENCE The number of the position where the chain occurred\nCHAININFO_TARGET_CARDS Chain of object cards\nCHAININFO_TARGET_PLAYER The target player for the chain\nCHAININFO_TARGET_PARAM The object parameters of the chain\nCHAININFO_DISABLE_REASON The chain is invalid for the effect of the effect\nCHAININFO_DISABLE_PLAYER The chain is invalid for the reason the player\nCHAININFO_CHAIN_ID The unique identifier for the chain\nCHAININFO_TYPE Type of Chain Card (Monster, Magic, Trap)\nCHAININFO_EXTTYPE The specific type of chain card (for example, monster, continuous magic, counterattack trap)\nFor example:\nDuel.GetChainInfo (0, CHAININFO_TRIGGERING_LOCATION, CHAININFO_TARGET_CARDS)\nThis will return the location and object card where the current chain occurred",
        "text": "GetChainInfo",
        "ret": ""
      },
      {
        "args": [
          "ec",
          "code",
          "re",
          "r",
          "rp",
          "ep",
          "ev"
        ],
        "desc": "Duel.RaiseSingleEvent(ec: Card, code: int, re: Effect, r: int, rp: int, ep: int, ev: int)\n\nTo eg, ep, ev, re, r, rp for the card ec trigger a single point in time",
        "text": "RaiseSingleEvent",
        "ret": ""
      },
      {
        "args": [
          "player",
          "c",
          "pos"
        ],
        "desc": "Duel.SelectPosition(player: int, c: Card, pos: int)\n\nLet player player select the Battle Position of c and return.",
        "text": "SelectPosition",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "value",
          "reason"
        ],
        "desc": "Duel.Recover(player: int, value: int, reason: int [, is_step: boolean = false])\n\nTo reason reason players to player value LP, return to the actual response value\nThe return value is 0 if it is affected by an effect such as a return to harm.\nIs_step to true is the damage / recovery LP process decomposition, need to call Duel.RDComplete () trigger point.",
        "text": "Recover",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "s",
          "o",
          "min",
          "max",
          "reason"
        ],
        "desc": "Duel.RemoveOverlayCard(player: int, s: int, o: int, min: int, max: int, reason: int)\n\nLet the player remove the min-max overlay card at the specified location for the reason reason. The return value indicates success",
        "text": "RemoveOverlayCard",
        "ret": "boolean"
      },
      {
        "args": [],
        "desc": "Duel.GetCurrentPhase()\n\nReturns the current stage",
        "text": "GetCurrentPhase",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "code"
        ],
        "desc": "Duel.ResetFlagEffect(player: int, code: int)\n\nManually reset the player player's specific logo effect",
        "text": "ResetFlagEffect",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Duel.ReplaceAttackTarget(c: Card)\n\n(Reserved)",
        "text": "ReplaceAttackTarget",
        "ret": ""
      },
      {
        "args": [
          "c",
          "tuner",
          "f1",
          "f2",
          "min",
          "max"
        ],
        "desc": "Duel.CheckTunerMaterial(c: Card, tuner: Card, f1: function, f2: function, min: int, max: int [, mg: Group])\n\nCheck to tuner as an adjustment [in the mg] whether there is a set of min-max card to meet the conditions as cohort call c material\nF1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions",
        "text": "CheckTunerMaterial",
        "ret": "boolean"
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Duel.CalculateDamage(c1: Card, c2: Card)\n\nLet c1 and c2 combat damage calculation",
        "text": "CalculateDamage",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.CheckSummonedCount([c: Card])\n\nCheck whether the round player can still summon this turn [Card c]",
        "text": "CheckSummonedCount",
        "ret": "boolean"
      },
      {
        "args": [
          "f",
          "player",
          "s",
          "o",
          "ex"
        ],
        "desc": "Duel.GetMatchingGroup(f: function, player: int, s: int, o: int, ex: Card | nil, ...)\n\nFilter function to return to the specified location to meet the filter condition f and not equal to the ex card.\nThe sixth parameter starts as an extra parameter.",
        "text": "GetMatchingGroup",
        "ret": "Group"
      },
      {
        "args": [
          "player",
          "count"
        ],
        "desc": "Duel.GetDecktopGroup(player: int, count: int)\n\nReturns the count card at the top of the player's deck",
        "text": "GetDecktopGroup",
        "ret": "Group"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.GetLP(player: int)\n\nReturns the current LP of the player's player",
        "text": "GetLP",
        "ret": "int"
      },
      {
        "args": [],
        "desc": "Duel.GetFirstTarget()\n\nReturns all linked object cards that are normally only used when an object is used",
        "text": "GetFirstTarget",
        "ret": "Card"
      },
      {
        "args": [],
        "desc": "Duel.NegateAttack()\n\nInvalid This attack, the return value indicates whether the success\nThis attack has been invalidated by other effects or cause the attack card can not attack is false",
        "text": "NegateAttack",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "s",
          "o"
        ],
        "desc": "Duel.GetFieldGroupCount(player: int, s: int, o: int)\n\nReturns the number of cards in the specified location",
        "text": "GetFieldGroupCount",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "win_reason"
        ],
        "desc": "Duel.Win(player: int, win_reason: int)\n\nThe current effect is dealt with so players win_reason duel victory",
        "text": "Win",
        "ret": ""
      },
      {
        "args": [
          "player",
          "s",
          "o"
        ],
        "desc": "Duel.GetOverlayGroup(player: int, s: int, o: int)\n\nReturns all stacked cards at a specified location",
        "text": "GetOverlayGroup",
        "ret": "Group"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.GetBattleDamage(player: int)\n\nReturns the player's player's damage during this battle",
        "text": "GetBattleDamage",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Duel.GetTributeGroup(c: Card)\n\nReturns the deck of cards used for the normal summon c to be released (for higher-level summons)",
        "text": "GetTributeGroup",
        "ret": "Group"
      },
      {
        "args": [
          "e",
          "c"
        ],
        "desc": "Duel.VenomSwampCheck(e: Effect, c: Card)\n\n",
        "text": "VenomSwampCheck",
        "ret": "boolean"
      },
      {
        "args": [],
        "desc": "Duel.EquipComplete()\n\nIn the call Duel.Equip, if is_step parameter is true, you need to call this function when the trigger point",
        "text": "EquipComplete",
        "ret": ""
      },
      {
        "args": [
          "player",
          "location"
        ],
        "desc": "Duel.GetLocationCount(player: int, location: int [, use_player: int, reason: int = LOCATION_REASON_TOFIELD])\n\nReturns the number of spaces available in the player's field\nLocation can only be LOCATION_MZONE or LOCATION_SZONE\nReason is LOCATION_REASON_TOFIELD or LOCATION_REASON_CONTROL",
        "text": "GetLocationCount",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "c"
        ],
        "desc": "Duel.IsPlayerCanSendtoHand(player: int, c: Card)\n\nCheck whether the player can send c to hand",
        "text": "IsPlayerCanSendtoHand",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "countertype",
          "count",
          "c"
        ],
        "desc": "Duel.IsCanAddCounter(player: int, countertype: int, count: int, c: Card)\n\nCheck if the player can add count counterstype to card c",
        "text": "IsCanAddCounter",
        "ret": "boolean"
      },
      {
        "args": [],
        "desc": "Duel.BreakEffect()\n\nInterrupt the current effect, so that after the effect of treatment as not treated simultaneously, this function will cause the wrong time",
        "text": "BreakEffect",
        "ret": ""
      },
      {
        "args": [
          "player",
          "lp"
        ],
        "desc": "Duel.SetLP(player: int, lp: int)\n\nSet the player's current LP to lp",
        "text": "SetLP",
        "ret": ""
      },
      {
        "args": [
          "chainc",
          "g"
        ],
        "desc": "Duel.ChangeTargetCard(chainc: int, g: Group)\n\nThe chain chainc the object into g",
        "text": "ChangeTargetCard",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.Readjust()\n\nRefresh the card information on the field\nUnspecified or unclear principle Do not use this function to anil an infinite loop",
        "text": "Readjust",
        "ret": ""
      },
      {
        "args": [
          "g"
        ],
        "desc": "Duel.ReleaseRitualMaterial(g: Group)\n\nLiberation ceremony with the material g, if the ceremony is the cemetery and other magic cards are excluded",
        "text": "ReleaseRitualMaterial",
        "ret": ""
      },
      {
        "args": [
          "player",
          "c",
          "min",
          "max"
        ],
        "desc": "Duel.SelectTribute(player: int, c: Card, min: int, max: int [, mg: Group, ex: boolean = false])\n\nLet the player player [from the mg] choose the min-max sacrifices that are normally used to summon c, ex = true to allow the monster on the other side of the field (the wing of the Sun God-Sphere).",
        "text": "SelectTribute",
        "ret": "Group"
      },
      {
        "args": [],
        "desc": "Duel.GetTurnPlayer()\n\nReturns the current round of players",
        "text": "GetTurnPlayer",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "count",
          "reason"
        ],
        "desc": "Duel.DiscardDeck(player: int, count: int, reason: int)\n\nTo reason player player card group top count cards sent to the cemetery, the actual transfer of the number.",
        "text": "DiscardDeck",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "s",
          "o",
          "countertype",
          "count",
          "reason"
        ],
        "desc": "Duel.RemoveCounter(player: int, s: int, o: int, countertype: int, count: int, reason: int)\n\nCauses the player player to remove count objects of the countertype type present on the farm for reason reasons. The return value indicates success\nS represents the position of the player's own removable pointer, o represents the position of the opponent's removable pointer for the player",
        "text": "RemoveCounter",
        "ret": "boolean"
      },
      {
        "args": [
          "targets",
          "reason"
        ],
        "desc": "Duel.Destroy(targets: Card | Group, reason: int [, dest: int = LOCATION_GRAVE])\n\nDestroy targets dest by reason reason, the return value is actually destroyed by the number\nIf the reason contains REASON_RULE, the break event will not check whether the card is immune,\nDoes not trigger the generation of breaking effect and ignore the \"can not destroy\"",
        "text": "Destroy",
        "ret": "int"
      },
      {
        "args": [
          "targets",
          "player",
          "reason"
        ],
        "desc": "Duel.SendtoHand(targets: Card | Group, player: int | nil, reason: int)\n\nThe reason to target the player sent to the player's hand, the return value is the actual number of operations",
        "text": "SendtoHand",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "count",
          "available"
        ],
        "desc": "Duel.AnnounceRace(player: int, count: int, available: int)\n\nLet the player player declare count races from the optional races\nAvailable is the combined value of all the optional races",
        "text": "AnnounceRace",
        "ret": "int"
      },
      {
        "args": [],
        "desc": "Duel.SetTargetParam(integer [, param])\n\nSets the object parameters of the chain that is currently being processed into param",
        "text": "SetTargetParam",
        "ret": ""
      },
      {
        "args": [
          "player",
          "value",
          "reason"
        ],
        "desc": "Duel.Damage(player: int, value: int, reason: int [, is_step: boolean = false])\n\nTo the reason reason to give players the player caused value damage, the actual value of the damage received.\nThe return value is 0 if the damage becomes an effect such as a reply.\nIs_step to true is the damage / recovery LP process decomposition, need to call Duel.RDComplete () trigger point.",
        "text": "Damage",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "c",
          "tuner"
        ],
        "desc": "Duel.SynchroSummon(player: int, c: Card, tuner: Card [, mg: Group])\n\nLet the player player to tuner as the adjustment [mg for the material] on the c cohomology summon procedures",
        "text": "SynchroSummon",
        "ret": ""
      },
      {
        "args": [
          "player",
          "targets"
        ],
        "desc": "Duel.SSet(player: int, targets: Card | Group [, target_player: int = player])\n\nLet the player player place the targets into the target trap's magic trap\nIf targets is Group, the number of successful operations is returned",
        "text": "SSet",
        "ret": "nil"
      },
      {
        "args": [],
        "desc": "Duel.ClearTargetCard()\n\nThe current processing of the chain of all the objects cleared",
        "text": "ClearTargetCard",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.CheckPhaseActivity()\n\nCheck the player at the current stage whether the operation (whether at the beginning of the stage, such as the Seven King of the sword)",
        "text": "CheckPhaseActivity",
        "ret": "boolean"
      },
      {
        "args": [],
        "desc": "Duel.SpecialSummonComplete()\n\nThis function is called after determining that a number of calls to Duel.SpecialSummonStep are completed, for triggering an event",
        "text": "SpecialSummonComplete",
        "ret": "nil"
      },
      {
        "args": [
          "event"
        ],
        "desc": "Duel.CheckEvent(event: int [, get_info: boolean])\n\nCheck whether the current event point\nIf get_info = true and is the correct time point also returns the trigger point information eg, ep, ev, re, r, rp",
        "text": "CheckEvent",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "f",
          "min",
          "max",
          "ex"
        ],
        "desc": "Duel.SelectReleaseGroupEx(player: int, f: function, min: int, max: int, ex: Card | nil, ...)\n\nFilter function, allowing the player player from the field · hand card selection min-max Zhang does not equal ex to meet the conditions of f can be liberated card (non-superior call)",
        "text": "SelectReleaseGroupEx",
        "ret": "Group"
      },
      {
        "args": [],
        "desc": "Duel.GetEnvironment()\n\nReturns the two values ​​that represent the current venue code, as well as the source of the current venue effect\nThe site code refers to the code of the venue card in effect, or the value of the effect of the venue change\nSource Player is the controller of the card in effect, or the controller of the Poseidon Witch, etc.",
        "text": "GetEnvironment",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "value"
        ],
        "desc": "Duel.ChangeBattleDamage(player: int, value: int [, check: boolean = true])\n\nThe player player in this battle by the harm into value, check for false is the original combat damage to 0 also change the damage",
        "text": "ChangeBattleDamage",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Duel.ChangeAttackTarget(c: Card | nil)\n\nWill attack the object into c, c for nil that direct attack, the return value indicates whether the successful transfer of attack objects",
        "text": "ChangeAttackTarget",
        "ret": "boolean"
      },
      {
        "args": [],
        "desc": "Duel.GetOperatedGroup()\n\nThis function returns a card set that was actually manipulated before a card operation\nDuel. Destroy, Duel.Remove, Duel.SendtoGrave,\nDuel.SendtoHand, Duel.SendtoDeck, Duel.SendtoExtraP, Duel.Release,\nDuel.ChangePosition, Duel.SpecialSummon, Duel.DiscardDeck",
        "text": "GetOperatedGroup",
        "ret": "Group"
      },
      {
        "args": [],
        "desc": "Duel.IsAbleToEnterBP()\n\nCheck whether the player can enter the combat phase of the round",
        "text": "IsAbleToEnterBP",
        "ret": "boolean"
      },
      {
        "args": [
          "counter_id",
          "player",
          "activity_type"
        ],
        "desc": "Duel.GetCustomActivityCount(counter_id: int, player: int, activity_type: int)\n\nCounter number counter_id count, the number of players to return to the following (currently up to 1)\nThe activity_type is of the following type\nACTIVITY_SUMMON call (not including the usual call set)\nACTIVITY_NORMALSUMMON usually called (including the usual call set)\nACTIVITY_SPSUMMON Special call\nACTIVITY_FLIPSUMMON Reverse call\nACTIVITY_CHAIN ​​Activates the effect",
        "text": "GetCustomActivityCount",
        "ret": "int"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Duel.SetFusionMaterial(g: Group)\n\nSet g to be the fusion material you want to use",
        "text": "SetFusionMaterial",
        "ret": ""
      },
      {
        "args": [
          "chainc",
          "c"
        ],
        "desc": "Duel.CheckChainTarget(chainc: int, c: Card)\n\nCheck whether c is the correct object for chained chainc effects",
        "text": "CheckChainTarget",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "c"
        ],
        "desc": "Duel.IsPlayerCanFlipSummon(player: int, c: Card)\n\nCheck whether the player can reverse the call player c",
        "text": "IsPlayerCanFlipSummon",
        "ret": "boolean"
      },
      {
        "args": [
          "chainc"
        ],
        "desc": "Duel.GetOperationCount(chainc: int)\n\nReturns the number of operational classifications contained in chained chainc",
        "text": "GetOperationCount",
        "ret": "int"
      },
      {
        "args": [
          "c",
          "seq"
        ],
        "desc": "Duel.MoveSequence(c: Card, seq: int)\n\nMove the serial number of c, usually used to change the grid in the field or in the card group to move to the top or bottom",
        "text": "MoveSequence",
        "ret": ""
      },
      {
        "args": [
          "cards"
        ],
        "desc": "Duel.SetSelectedCard(cards: Card | Group)\n\nSet the card to the selected card for Group.SelectWithSumEqual or Group.SelectWithSumGreater,",
        "text": "SetSelectedCard",
        "ret": ""
      },
      {
        "args": [
          "targets",
          "reason"
        ],
        "desc": "Duel.Release(targets: Card | Group, reason: int)\n\nThe reason for the liberation of targets to return the value of the actual liberation of the number of targets\nIf the reason contains REASON_COST, it will not check whether the card is not affected by the effect",
        "text": "Release",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "c"
        ],
        "desc": "Duel.IsPlayerCanSendtoDeck(player: int, c: Card)\n\nCheck whether the player can send c to the card group",
        "text": "IsPlayerCanSendtoDeck",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "c"
        ],
        "desc": "Duel.IsPlayerCanSendtoGrave(player: int, c: Card)\n\nCheck whether the player can send c to the cemetery",
        "text": "IsPlayerCanSendtoGrave",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "code",
          "reset_flag",
          "property",
          "reset_count"
        ],
        "desc": "Duel.RegisterFlagEffect(player: int, code: int, reset_flag: int, property: int, reset_count: int)\n\nFor the player to register the global environment logo effect\nThis effect always affects the player's (EFFECT_FLAG_PLAYER_TARGET) and will not be invalidated\nThe rest is the same as Card.RegisterFlagEffect",
        "text": "RegisterFlagEffect",
        "ret": "Effect"
      },
      {
        "args": [
          "player",
          "c"
        ],
        "desc": "Duel.IsPlayerCanRemove(player: int, c: Card)\n\nCheck whether the player player except c",
        "text": "IsPlayerCanRemove",
        "ret": "boolean"
      },
      {
        "args": [
          "f",
          "player",
          "s",
          "o",
          "ex"
        ],
        "desc": "Duel.GetMatchingGroupCount(f: function, player: int, s: int, o: int, ex: Card | nil, ...)\n\nFilter function to return to the specified location to meet the filter condition f and not equal to the number of ex card.",
        "text": "GetMatchingGroupCount",
        "ret": "int"
      },
      {
        "args": [
          "targets"
        ],
        "desc": "Duel.NegateSummon(targets: Card | Group)\n\nSo that the call is being summoned · reverse call special summoned targets invalid",
        "text": "NegateSummon",
        "ret": ""
      },
      {
        "args": [
          "player",
          "f",
          "count",
          "ex"
        ],
        "desc": "Duel.CheckReleaseGroupEx(player: int, f: function, count: int, ex: Card | nil, ...)\n\nCheck whether there are at least count cards that can satisfy the filter condition f and are not equal to ex. (For non-superior summoning)",
        "text": "CheckReleaseGroupEx",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "c"
        ],
        "desc": "Duel.IsPlayerCanRelease(player: int, c: Card)\n\nCheck whether the player can liberate the player c",
        "text": "IsPlayerCanRelease",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "reset"
        ],
        "desc": "Duel.NegateRelatedChain(c: Card, reset: int)\n\nSo that card c has launched the chain are invalid, reset event occurs reset",
        "text": "NegateRelatedChain",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Duel.ReturnToField(c: Card [, pos: int])\n\nTo return the form c to the field pos, pos default value is the expression before leaving the field, the return value indicates whether the success\nC must be a REASON_TEMPORARY reason to leave, and leave the position did not leave that position",
        "text": "ReturnToField",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "count"
        ],
        "desc": "Duel.IsPlayerCanDiscardDeck(player: int, count: int)\n\nCheck player player can put the card group top count cards sent to the cemetery",
        "text": "IsPlayerCanDiscardDeck",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "count"
        ],
        "desc": "Duel.IsPlayerCanSpecialSummonCount(player: int, count: int)\n\nCheck whether the player player special call count times",
        "text": "IsPlayerCanSpecialSummonCount",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "code",
          "setcode",
          "type",
          "atk",
          "def",
          "level",
          "race",
          "attribute"
        ],
        "desc": "Duel.IsPlayerCanSpecialSummonMonster(player: int, code: int, setcode: int, type: int, atk: int, def: int, level: int, race: int, attribute: int [, pos: Integer = POS_FACEUP, target_player: integer = player, sumtype: int])\n\nCheck player player can be pos to the form of special summon the parameters of the monster to the target_player field\nThis function is usually used to determine whether it is possible to trick token and trap monsters",
        "text": "IsPlayerCanSpecialSummonMonster",
        "ret": "boolean"
      },
      {
        "args": [
          "targets",
          "reason"
        ],
        "desc": "Duel.SendtoGrave(targets: Card | Group, reason: int)\n\nThe reason for the targets to the cemetery, the return value is the actual number of operations",
        "text": "SendtoGrave",
        "ret": "int"
      },
      {
        "args": [
          "chainc"
        ],
        "desc": "Duel.IsChainDisablable(chainc: int)\n\nCheck chainC effect can be invalid",
        "text": "IsChainDisablable",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "s",
          "o",
          "countertype",
          "count",
          "reason"
        ],
        "desc": "Duel.IsCanRemoveCounter(player: int, s: int, o: int, countertype: int, count: int, reason: int)\n\nChecks whether the player player can remove count objects of the countertype type on the farm for reason reasons\nS represents the position of the player's own removable pointer, o represents the position of the opponent's removable pointer for the player.",
        "text": "IsCanRemoveCounter",
        "ret": "boolean"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.IsPlayerCanSpecialSummon(player: int [, sumtype: int, sumpos: int, target_player: int, c: Card])\n\nCheck player player can special summon [c to target_player field to sumtype summation, sumpos form]\nIf optional parameters are required, they must all be used",
        "text": "IsPlayerCanSpecialSummon",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "count"
        ],
        "desc": "Duel.IsPlayerCanDiscardDeckAsCost(player: int, count: int)\n\nCheck the player player can put the card group top count cards sent to the cemetery as cost",
        "text": "IsPlayerCanDiscardDeckAsCost",
        "ret": "boolean"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.IsPlayerCanDraw(player: int [, count: int = 0])\n\nCheck the player player can effect pumping [count Zhang] card",
        "text": "IsPlayerCanDraw",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "code"
        ],
        "desc": "Duel.IsPlayerAffectedByEffect(player: int, code: int)\n\nCheck if the player is affected by the effect of the code type, and return the effect if there is one",
        "text": "IsPlayerAffectedByEffect",
        "ret": "Effect"
      },
      {
        "args": [
          "res"
        ],
        "desc": "Duel.SetDiceResult(res: int, ...)\n\nForcibly modify the result of casting dice to res\nThis function is used in the persistent EVENT_TOSS_DICE event",
        "text": "SetDiceResult",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "Duel.ChangeAttacker(c: Card)\n\nWill attack the monster into c\nNote: This function will make the original attack monster attack",
        "text": "ChangeAttacker",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.GetDiceResult()\n\nReturns the result of the current dice",
        "text": "GetDiceResult",
        "ret": "int"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.GetReleaseGroupCount(player: int [, use_hand: boolean = false])\n\nReturn player player can be liberated (non-superior summoned with) the number of cards, use_hand is true, including the hand card",
        "text": "GetReleaseGroupCount",
        "ret": "integer"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.GetDrawCount(player: int)\n\nReturns the player's number of rules drawn per turn",
        "text": "GetDrawCount",
        "ret": "int"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.ShuffleHand(player: int)\n\nManual wash player player's hand card\nNOTE: The status of the wash detection is reset",
        "text": "ShuffleHand",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.GetCoinResult()\n\nReturns the result of the current coin",
        "text": "GetCoinResult",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "count1"
        ],
        "desc": "Duel.TossDice(player: int, count1: int [, count2: int = 0])\n\nLet the player to cast count1 dice [, 1-player to vote count2 dice] (count1 + count2 <= 5)\nThe return value is count1 + count2 results, 1-6",
        "text": "TossDice",
        "ret": ""
      },
      {
        "args": [
          "player",
          "count"
        ],
        "desc": "Duel.TossCoin(player: int, count: int)\n\nLet the player player cast count (<= 5) coins, the return value for the count results, 0 or 1.",
        "text": "TossCoin",
        "ret": ""
      },
      {
        "args": [
          "f",
          "player",
          "s",
          "o",
          "count",
          "ex"
        ],
        "desc": "Duel.IsExistingMatchingCard(f: function, player: int, s: int, o: int, count: int, ex: Card | nil, ...)\n\nFilter the function to check if there are at least count cards that satisfy the filter condition f and not equal to ex\nThe seventh argument starts as an extra parameter",
        "text": "IsExistingMatchingCard",
        "ret": "boolean"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.AnnounceCard(player: int [, type = TYPE_MONSTER + TYPE_SPELL + TYPE_TRAP])\n\nLet players declare a player [type type] card code",
        "text": "AnnounceCard",
        "ret": "int"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.AnnounceLevel(player: int)\n\nLet the player declare a level",
        "text": "AnnounceLevel",
        "ret": "int"
      },
      {
        "args": [],
        "desc": "Duel.IncreaseSummonedCount([c: Card])\n\nManual consumption of 1 player [for card c] the number of the usual call",
        "text": "IncreaseSummonedCount",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.GetTurnCount()\n\nReturns the current number of turns",
        "text": "GetTurnCount",
        "ret": "int"
      },
      {
        "args": [
          "targets",
          "sumtype",
          "sumplayer",
          "target_player",
          "nocheck",
          "nolimit",
          "pos"
        ],
        "desc": "Duel.SpecialSummon(targets: Card | Group, sumtype: int, sumplayer: int, target_player: int, nocheck: boolean, nolimit: boolean, pos: int)\n\nLet player player to sumtype way, pos that special targets to target_player target field\nIf nocheck is true, the card's calling condition is disregarded. If nolimit is true,\nThe return value is the number of cards that were successfully summoned.",
        "text": "SpecialSummon",
        "ret": "int"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.AnnounceType(player: int)\n\nLet the player player declare a card type",
        "text": "AnnounceType",
        "ret": "int"
      },
      {
        "args": [
          "f"
        ],
        "desc": "Duel.SetChainLimit(f: function)\n\nSet the chain conditions, f function prototype for boolean f (e, ep, tp)\nE said to limit the effect of chain, ep said to limit the chain of players, tp that launched the effect of the players\nCalling this function in cost or target processing can limit the kinds of effects that can be chained (such as superfusion)\nIf f returns false, it means that the chain can not be chained. Once the chain condition has been set, the new chain will be canceled.",
        "text": "SetChainLimit",
        "ret": ""
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.AnnounceCoin(player: int)\n\nLet the player declare the positive and negative sides of the coin",
        "text": "AnnounceCoin",
        "ret": "int"
      },
      {
        "args": [
          "chainc"
        ],
        "desc": "Duel.NegateEffect(chainc: int)\n\nSo that the chain chainc invalid effect, the return value that is successful",
        "text": "NegateEffect",
        "ret": "boolean"
      },
      {
        "args": [
          "targets",
          "au"
        ],
        "desc": "Duel.ChangePosition(targets: Card | Group, au: int [, ad: int = au, du: int = au, dd: int = au, noflip: boolean = false, setavailable: boolean = false])\n\nChanges the Battle Position of targets returns the number of actual operations\nThe attack on the watch side becomes au, the attack on the inside indicates ad,\nThe side of the garage that becomes du, inside the garrison said to become dd\nIf noflip = true, the reverse effect will not be triggered (but the effect of inversion will be triggered)\nIf setavailable = true then the object will become the back side also launched reversal effect",
        "text": "ChangePosition",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "count",
          "available"
        ],
        "desc": "Duel.AnnounceAttribute(player: int, count: int, available: int)\n\nLet the player player declare count attributes from the optional attribute\nAvailable is the combined value of all optional attributes",
        "text": "AnnounceAttribute",
        "ret": "int"
      },
      {
        "args": [],
        "desc": "Duel.ChainAttack([c: Card])\n\nSo that the attack card [or card c] can be carried out an attack (opening up, the queen of the Queen)",
        "text": "ChainAttack",
        "ret": ""
      },
      {
        "args": [
          "targets",
          "pos",
          "reason"
        ],
        "desc": "Duel.Remove(targets: Card | Group, pos: int, reason: int)\n\nIn the case of reason, except for the pos form, the return value is the actual number being manipulated\nIf the reason contains REASON_TEMPORARY, then the exception is considered temporary, you can return to the field by Duel.ReturnToField",
        "text": "Remove",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "count",
          "s",
          "o",
          "filter"
        ],
        "desc": "Duel.SelectDisableField(player: int, count: int, s: int, o: int, filter: int)\n\nLet the player player select the specified position to meet the marker condition filter count of the available space, and return to select the location of the marker\nCommonly used to select areas can not use or move the monster grid",
        "text": "SelectDisableField",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "Duel.GetTributeCount(c: Card [, mg: Group, ex: boolean = false])\n\nReturns the number of sacrifices that are normally used to invoke c, where ex = true allows monsters on the other side of the field (the wing of the Sun God-Sphere)\nThis number does not necessarily equal the number of cards in the return value of Duel.GetTributeGroup\nBecause some cards can be used as two sacrifices",
        "text": "GetTributeCount",
        "ret": "int"
      },
      {
        "args": [],
        "desc": "Duel.SelectSequence()\n\n",
        "text": "SelectSequence",
        "ret": ""
      },
      {
        "args": [
          "player",
          "c"
        ],
        "desc": "Duel.SelectEffectYesNo(player: int, c: Card)\n\nLet players choose whether to launch the card player c effect",
        "text": "SelectEffectYesNo",
        "ret": "boolean"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Duel.HintSelection(g: Group)\n\nManually displays the animated effect of the selected object for g and records that the card is selected as the object",
        "text": "HintSelection",
        "ret": ""
      },
      {
        "args": [
          "targets",
          "player"
        ],
        "desc": "Duel.GetControl(targets: Card | Group, player: int [, reset_phase: int = 0, reset_count: int = 0])\n\nLet players get control of the player, the return value indicates success",
        "text": "GetControl",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "s",
          "o"
        ],
        "desc": "Duel.GetOverlayCount(player: int, s: int, o: int)\n\nReturns the number of all stacked cards in the specified location.",
        "text": "GetOverlayCount",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "c",
          "ignore_count",
          "e"
        ],
        "desc": "Duel.Summon(player: int, c: Card, ignore_count: boolean, e: Effect | nil [, min = 0])\n\nLet the player to the effect of e to c is usually called (not set), at least use min sacrifice\nIf e = nil, then in accordance with the general rules of the general call usually call\nIf ignore_count = true, the usual number of calls per turn limit is ignored",
        "text": "Summon",
        "ret": ""
      },
      {
        "args": [
          "player",
          "location",
          "seq"
        ],
        "desc": "Duel.CheckLocation(player: int, location: int, seq: int)\n\nCheck if the player's player field is seq in the location of the space is available",
        "text": "CheckLocation",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "ocard"
        ],
        "desc": "Duel.Overlay(c: Card, ocard: Card | Group)\n\nThe ocard as a stack of cards stacked c",
        "text": "Overlay",
        "ret": ""
      },
      {
        "args": [
          "c",
          "f",
          "lv",
          "min",
          "max",
          "mg"
        ],
        "desc": "Duel.CheckXyzMaterial(c: Card, f: function, lv: int, min: int, max: int, mg: Group | nil)\n\nCheck on the field or mg in the presence of excess call c excess with the level of lv min-max meet the conditions of the stack f material",
        "text": "CheckXyzMaterial",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "count"
        ],
        "desc": "Duel.ConfirmDecktop(player: int, count: int)\n\nConfirm the player card group above count cards",
        "text": "ConfirmDecktop",
        "ret": ""
      },
      {
        "args": [
          "chainc",
          "category",
          "targets",
          "count",
          "target_player",
          "target_param"
        ],
        "desc": "Duel.SetOperationInfo(chainc: int, category: int, targets: Card | Group, count: int, target_player: int, target_param: int)\n\nSets the operation information of the currently processed chain This operation information contains the effect classification determined in the effect processing to be processed\nFor example, stealth snipers need to set CATEGORY_DICE, but can not set CATEGORY_DESTROY, because not sure\nFor destructive effects, targets need to be set to launch the object may become the impact of chain card,\nAnd sets count to the number of cards to be processed as determined at launch\nFor example, when the black hole launched, targets need to be set to all the monsters on the field, count to set the number of strange field\nFor CATEGORY_SPECIAL_SUMMON, CATEGORY_TOHAND, CATEGORY_TODECK, etc., which need to move the card position,\nIf the card to be processed is deterministic (such as fetching objects), set targets for these cards, count for the number,\nIf the card to be processed is uncertain (the effect can be determined when processing, is generally not take the effect of the object)\nSet the targets to nil, count is expected to deal with the number of cards,\nTarget_player is expected to be handled by the holder of the card (not sure to 0)\nTarget_param is the location of the card expected to be processed\nFor example: SetOperationInfo (0, CATEGORY_TOHAND, nil, 1, tp, LOCATION_DECK)\nOperational information is used to initiate detection of many effects, such as Stardust Dragon, Royal Valley",
        "text": "SetOperationInfo",
        "ret": ""
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.SetTargetPlayer(player: int)\n\nSet the player that is currently handling the chained object to player",
        "text": "SetTargetPlayer",
        "ret": ""
      },
      {
        "args": [
          "targets"
        ],
        "desc": "Duel.SetTargetCard(targets: Card | Group)\n\nSets the currently chained objects to targets\nNote that here the object refers to the generalized object, including objects that do not take the effect that the object may have to deal with",
        "text": "SetTargetCard",
        "ret": ""
      },
      {
        "args": [
          "player",
          "count",
          "reason"
        ],
        "desc": "Duel.Draw(player: int, count: int, reason: int)\n\nLet the player play the count card with the reason, and return the number of cards actually drawn\nIf the reason contains REASON_RULE the draw is not affected by the \"can not draw\" effect",
        "text": "Draw",
        "ret": "int"
      },
      {
        "args": [
          "chainc"
        ],
        "desc": "Duel.IsChainNegatable(chainc: int)\n\nCheck the chain chainc launch can be invalid",
        "text": "IsChainNegatable",
        "ret": "boolean"
      },
      {
        "args": [
          "c1",
          "c2"
        ],
        "desc": "Duel.SwapControl(c1: Card, c2: Card [, reset_phase: int = 0, reset_count: int = 0])\n\nExchange c1 and c2 control, the return value that is successful",
        "text": "SwapControl",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "c",
          "tuner",
          "f1",
          "f2",
          "min",
          "max"
        ],
        "desc": "Duel.SelectTunerMaterial(player: int, c: Card, tuner: Card, f1: function, f2: function, min: int, max: int [, mg: Group])\n\nLet the player [from the mg] select a set of clips of the min-max cards that are tuned to be used for co-ordination of the required conditions for c.\nF1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions",
        "text": "SelectTunerMaterial",
        "ret": "Group"
      },
      {
        "args": [
          "player",
          "c",
          "f1",
          "f2",
          "min",
          "max"
        ],
        "desc": "Duel.SelectSynchroMaterial(player: int, c: Card, f1: function, f2: function, min: int, max: int [, smat: Card, mg: Group])\n\nLet the player player [from mg] select a set of clips that are required for the cohomology c [must contain smat (if there is mg ~ = nil this parameter is ignored)] The number of min-max clips that satisfy the condition\nF1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions",
        "text": "SelectSynchroMaterial",
        "ret": "Group"
      },
      {
        "args": [
          "f",
          "player",
          "s",
          "o",
          "ex"
        ],
        "desc": "Duel.GetTargetCount(f: function, player: int, s: int, o: int, ex: Card | nil, ...)\n\nBasic with Duel.GetMatchingGroupCount, the difference lies in the need to add to determine whether the card is currently being processed by the effect of the object.",
        "text": "GetTargetCount",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "activity_type"
        ],
        "desc": "Duel.GetActivityCount(player: int, activity_type: int, ...)\n\nReturns the number of times the player performed the corresponding activity_type operation\nThe activity_type is of the following type\nACTIVITY_SUMMON call (not including the usual call placed)\nACTIVITY_NORMALSUMMON Usually called (including the usual call placed)\nACTIVITY_SPSUMMON Special call\nACTIVITY_FLIPSUMMON Reverse call\nACTIVITY_ATTACK attack\nACTIVITY_BATTLE_PHASE enters the combat phase",
        "text": "GetActivityCount",
        "ret": "int"
      },
      {
        "args": [
          "g"
        ],
        "desc": "Duel.SetSynchroMaterial(g: Group)\n\nSet g to be the cohomology material you want to use",
        "text": "SetSynchroMaterial",
        "ret": ""
      },
      {
        "args": [
          "timing"
        ],
        "desc": "Duel.CheckTiming(timing: int)\n\nCheck whether the current prompt is the timing point",
        "text": "CheckTiming",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "f",
          "count",
          "ex"
        ],
        "desc": "Duel.CheckReleaseGroup(player: int, f: function, count: int, ex: Card | nil, ...)\n\nCheck if the player has at least count of cards that meet the filter condition f and are not equal to ex (non-superior summons)\nThe fifth parameter starts as an extra parameter",
        "text": "CheckReleaseGroup",
        "ret": "boolean"
      },
      {
        "args": [
          "chainc",
          "player"
        ],
        "desc": "Duel.ChangeTargetPlayer(chainc: int, player: in)\n\nThe chain chainc the object player into player",
        "text": "ChangeTargetPlayer",
        "ret": ""
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.GetReleaseGroup(player: int [, use_hand: boolean = false])\n\nReturn to the player player can be liberated (non-superior summoned use) of the deck, use_hand is true, including the hand card",
        "text": "GetReleaseGroup",
        "ret": "Group"
      },
      {
        "args": [
          "sel_player",
          "f",
          "player",
          "s",
          "o",
          "min",
          "max",
          "ex"
        ],
        "desc": "Duel.SelectMatchingCard(sel_player: int, f: function, player: int, s: int, o: int, min: int, max: int, ex: Card | nil, ...)\n\nFilter function, the player sel_player select the specified location to meet the filter condition f and not equal to the ex min-max card\nThe ninth parameter starts as an extra parameter",
        "text": "SelectMatchingCard",
        "ret": "Group"
      },
      {
        "args": [
          "player",
          "code"
        ],
        "desc": "Duel.GetFlagEffect(player: int, code: int)\n\nReturns the number of specific marker effects for the player's player",
        "text": "GetFlagEffect",
        "ret": "int"
      },
      {
        "args": [],
        "desc": "Duel.GetCurrentChain()\n\nReturns the chain number currently being processed",
        "text": "GetCurrentChain",
        "ret": "int"
      },
      {
        "args": [
          "player",
          "c"
        ],
        "desc": "Duel.SpecialSummonRule(player: int, c: Card)\n\nLet player player on c special summon procedures",
        "text": "SpecialSummonRule",
        "ret": ""
      },
      {
        "args": [
          "player",
          "s",
          "o"
        ],
        "desc": "Duel.GetFieldGroup(player: int, s: int, o: int)\n\nReturns the card at the specified location",
        "text": "GetFieldGroup",
        "ret": "Group"
      },
      {
        "args": [
          "eg",
          "code",
          "re",
          "r",
          "rp",
          "ep",
          "ev"
        ],
        "desc": "Duel.RaiseEvent(eg: Group | Card, code: int, re: Effect, r: int, rp: int, ep: int, ev: int)\n\nTo eg, ep, ev, re, r, rp trigger a point in time",
        "text": "RaiseEvent",
        "ret": ""
      },
      {
        "args": [],
        "desc": "Duel.GetAttackTarget()\n\nReturn to the battle was attacked card, if the return nil said that a direct attack",
        "text": "GetAttackTarget",
        "ret": "Card"
      },
      {
        "args": [],
        "desc": "Duel.GetAttacker()\n\nReturn the card for this combat attack",
        "text": "GetAttacker",
        "ret": "Card"
      },
      {
        "args": [
          "player",
          "location",
          "seq"
        ],
        "desc": "Duel.GetFieldCard(player: int, location: int, seq: int)\n\nBack to player The player's field is located in the location number seq card, commonly used to obtain the field area · Spirit pendulum area card",
        "text": "GetFieldCard",
        "ret": "Card"
      },
      {
        "args": [
          "c",
          "sumtype",
          "sumplayer",
          "target_player",
          "nocheck",
          "nolimit",
          "pos"
        ],
        "desc": "Duel.SpecialSummonStep(c: Card, sumtype: int, sumplayer: int, target_player: int, nocheck: boolean, nolimit: boolean, pos: int)\n\nThis function is Duel.SpecialSummon decomposition process, only a special summon a card c\nThis function is used for an effect while simultaneously calling multiple cards with different parameters\nThis function must be used with Duel.SpecialSummonComplete\nThe return value indicates whether or not the special call succeeded",
        "text": "SpecialSummonStep",
        "ret": "boolean"
      },
      {
        "args": [
          "chainc",
          "param"
        ],
        "desc": "Duel.ChangeTargetParam(chainc: int, param: int)\n\nThe chain chainc parameters into param",
        "text": "ChangeTargetParam",
        "ret": ""
      },
      {
        "args": [
          "res"
        ],
        "desc": "Duel.SetCoinResult(res: int, ...)\n\nForcibly modify the result of casting coins to res\nThis function is used in the persistent EVENT_TOSS_COIN event",
        "text": "SetCoinResult",
        "ret": ""
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.ShuffleDeck(player: int)\n\nManually cleans the player group\nNOTE: The status of the wash detection is reset",
        "text": "ShuffleDeck",
        "ret": ""
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.GetRitualMaterial(player: int)\n\nReturns the player's deck of cards available for ritual summoning material\nIncluding hands, the field can be the liberation of the ceremony and the cemetery and other magic people card",
        "text": "GetRitualMaterial",
        "ret": "Group"
      },
      {
        "args": [
          "player",
          "cost"
        ],
        "desc": "Duel.PayLPCost(player: int, cost: int)\n\nAllow players to pay cost point player lp",
        "text": "PayLPCost",
        "ret": ""
      },
      {
        "args": [
          "player",
          "f",
          "min",
          "max",
          "reason",
          "ex"
        ],
        "desc": "Duel.DiscardHand(player: int, f: function, min: int, max: int, reason: int, ex: Card | nil, ...)\n\nFilter function allows the player to select and discard the player to meet the screening conditions f soldiers is not equal to ex min-max Zhang card.\nThe seventh argument starts as an extra parameter.",
        "text": "DiscardHand",
        "ret": "int"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.GetChainMaterial(player: int)\n\nReturns the effect of the chained material that is played by the player. This function is only used to blend the effect of a class card",
        "text": "GetChainMaterial",
        "ret": "Effect"
      },
      {
        "args": [
          "player",
          "s",
          "o",
          "count",
          "reason"
        ],
        "desc": "Duel.CheckRemoveOverlayCard(player: int, s: int, o: int, count: int, reason: int)\n\nCheck if the player can remove at least count cards for the specified reason",
        "text": "CheckRemoveOverlayCard",
        "ret": "boolean"
      },
      {
        "args": [
          "player",
          "c",
          "ignore_count",
          "e"
        ],
        "desc": "Duel.MSet(player: int, c: Card, ignore_count: boolean, e: Effect | nil [, min = 0])\n\nLet the player to the effect of c is usually called Set, at least use min sacrifice\nIf e = nil, then in accordance with the general rules of the general call usually call\nIf ignore_count = true, the usual number of calls per turn limit is ignored",
        "text": "MSet",
        "ret": ""
      },
      {
        "args": [
          "player",
          "c1",
          "c2"
        ],
        "desc": "Duel.Equip(player: int, c1: Card, c2: Card [, up: boolean = true, is_step: boolean = false])\n\nThe player as a player c1 equipment card equipment to the c2, the return value that is successful\nUp = false to retain the card before the representation\nIs_step = true is the decomposition of the equipment process, the need to cooperate with Duel.EquipComplete use",
        "text": "Equip",
        "ret": "boolean"
      },
      {
        "args": [
          "c",
          "move_player",
          "target_player",
          "dest",
          "pos",
          "enabled"
        ],
        "desc": "Duel.MoveToField(c: Card, move_player: int, target_player: int, dest: int, pos: int, enabled: boolean)\n\nLet the player move_player to move the c target_player field, the return value that is successful\nDest can only be LOCATION_MZONE or LOCATION_SZONE, pos represents an optional Battle Position, and enable indicates whether or not the effect of c is applied immediately",
        "text": "MoveToField",
        "ret": "boolean"
      },
      {
        "args": [
          "player"
        ],
        "desc": "Duel.SwapDeckAndGrave(player: int)\n\nThis world and the underworld reversal dedicated. The players player card group and the cemetery exchange",
        "text": "SwapDeckAndGrave",
        "ret": ""
      },
      {
        "args": [
          "sort_player",
          "target_player",
          "count"
        ],
        "desc": "Duel.SortDecktop(sort_player: int, target_player: int, count: int)\n\nLet the player sort_player on the player target_player card group at the top count card sort",
        "text": "SortDecktop",
        "ret": ""
      },
      {
        "args": [
          "chainc"
        ],
        "desc": "Duel.NegateActivation(chainc: int)\n\nSo that the chain chainc launch invalid, the return value that is successful",
        "text": "NegateActivation",
        "ret": "boolean"
      },
      {
        "args": [
          "e",
          "player"
        ],
        "desc": "Duel.RegisterEffect(e: Effect, player: int)\n\nRegister the effect e as the player's effect to the global environment",
        "text": "RegisterEffect",
        "ret": ""
      }
    ],
    "cls": "Duel"
  },
  {
    "methods": [
      {
        "args": [
          "f"
        ],
        "desc": "aux.TargetEqualFunction(f: function, value, a, b, c)\n\nReturn function (effect, target)\nReturn f (target, a, b, c) == value\nEnd",
        "text": "TargetEqualFunction",
        "ret": "function"
      },
      {
        "args": [
          "c",
          "f",
          "lv",
          "ct"
        ],
        "desc": "aux.AddXyzProcedure(c: Card, f: function, lv: int, ct: int [, alterf: function | nil, maxct: int = ct, op: function | nil])\n\nAdd an excess summon for c\nWith the conditions to meet the conditions for the f-level cv-maxct lv monster to be stacked\nThe rest of the parameters are used to stack on a single monster (usually an excess of monsters)\nAlterf for this monster to meet the conditions, desc for the description, op for the stacked operation (hope Huanglong)",
        "text": "AddXyzProcedure",
        "ret": ""
      },
      {
        "args": [
          "f"
        ],
        "desc": "aux.FilterEqualFunction(f: function, value, a, b, c)\n\nReturn function (target)\nReturn f (target, a, b, c) == value\nEnd",
        "text": "FilterEqualFunction",
        "ret": "function"
      },
      {
        "args": [
          "c",
          "f1",
          "f2",
          "ct"
        ],
        "desc": "aux.AddSynchroProcedure(c: Card, f1: function, f2: function, ct: int)\n\nAdd a cohomology call to c\nF1 to adjust the filter to meet the conditions, f2 to adjust to meet other than the filter conditions (usually aux.NonTuner)\nAdjust monsters other than ct at least",
        "text": "AddSynchroProcedure",
        "ret": ""
      },
      {
        "args": [
          "c",
          "f1",
          "f2",
          "insf"
        ],
        "desc": "aux.AddFusionProcFun2(c: Card, f1: function, f2: function, insf: boolean)\n\nFor the c to specify conditions for the f1 and f2 monsters for the fusion material",
        "text": "AddFusionProcFun2",
        "ret": ""
      },
      {
        "args": [
          "c"
        ],
        "desc": "aux.EnableDualAttribute(c: Card)\n\nAdd Gemini for the c monster attributes",
        "text": "EnableDualAttribute",
        "ret": ""
      },
      {
        "args": [
          "c",
          "code1",
          "code2",
          "code3",
          "code4",
          "sub",
          "insf"
        ],
        "desc": "aux.AddFusionProcCode4(c: Card, code1: int, code2: int, code3: int, code4: int, sub: boolean, insf: boolean)\n\nFor the c designated card number for the code1, code2, code3, code4 monster for the fusion material",
        "text": "AddFusionProcCode4",
        "ret": ""
      },
      {
        "args": [
          "c",
          "code",
          "cc",
          "sub",
          "insf"
        ],
        "desc": "aux.AddFusionProcCodeRep(c: Card, code: int, cc: int, sub: boolean, insf: boolean)\n\nFor the c designated cc the same monster for the fusion material, code for the card number",
        "text": "AddFusionProcCodeRep",
        "ret": ""
      },
      {
        "args": [
          "e"
        ],
        "desc": "aux.DualNormalCondition(e: Effect)\n\nCheck if the Gemini monster e: GetHandler () is considered a normal monster state",
        "text": "DualNormalCondition",
        "ret": "boolean"
      },
      {
        "args": [],
        "desc": "aux.BeginPuzzle()\n\nStart the mess",
        "text": "BeginPuzzle",
        "ret": ""
      },
      {
        "args": [
          "c",
          "code1",
          "code2",
          "sub",
          "insf"
        ],
        "desc": "aux.AddFusionProcCode2(c: Card, code1: int, code2: int, sub: boolean, insf: boolean)\n\nFor the c designated card number for the code1 and code2 monster for the fusion material\nSub that can use fusion instead of material, insf that can be summoned with a simple fusion",
        "text": "AddFusionProcCode2",
        "ret": ""
      },
      {
        "args": [
          "e"
        ],
        "desc": "aux.IsNotDualState(e: Effect)\n\nAntisense of aux.IsDualState",
        "text": "IsNotDualState",
        "ret": "boolean"
      },
      {
        "args": [
          "e"
        ],
        "desc": "aux.IsDualState(e: Effect)\n\nCheck the Gemini monster e: GetHandler () is re-call state\nCommonly used in the Gemini monster re-summoned to obtain the effect of e Condition attribute",
        "text": "IsDualState",
        "ret": "boolean"
      },
      {
        "args": [
          "code",
          "id"
        ],
        "desc": "aux.Stringid(code: int, id: int)\n\nUsed to index the card number code for the card the first id (from 0) effect prompts",
        "text": "Stringid",
        "ret": "int"
      },
      {
        "args": [
          "c"
        ],
        "desc": "aux.EnablePendulumAttribute(c: Card [, active_effect = true])\n\nFor the spirit to put the monster c to add the soul to put the monster attributes (spiritual swing call, the spirit of the launch of the card)\nActive_effect = false is not registered Ling card \"card launch\" effect",
        "text": "EnablePendulumAttribute",
        "ret": ""
      },
      {
        "args": [
          "f"
        ],
        "desc": "aux.TargetBoolFunction(f: function, a, b, c)\n\nReturn function (effect, target)\nReturn f (target, a, b, c)\nEnd",
        "text": "TargetBoolFunction",
        "ret": "function"
      },
      {
        "args": [
          "c",
          "f1",
          "f2"
        ],
        "desc": "aux.AddSynchroProcedure2(c: Card, f1: function, f2: function)\n\nAdd a cohomology call to c\nF1 to adjust the filter to meet the conditions, f2 to adjust to meet other than the filter conditions (usually aux.NonTuner)\nCan only be adjusted with a monster outside",
        "text": "AddSynchroProcedure2",
        "ret": ""
      },
      {
        "args": [
          "f"
        ],
        "desc": "aux.NonTuner(f: function, a, b, c)\n\nReturn function (target)\nReturn target: IsNotTuner () and (not f or f (target, a, b, c))\nEnd",
        "text": "NonTuner",
        "ret": "function"
      },
      {
        "args": [
          "c",
          "code",
          "f",
          "cc",
          "sub",
          "insf"
        ],
        "desc": "aux.AddFusionProcCodeFun(c: Card, code: int, f: function, cc: int, sub: boolean, insf: boolean)\n\nFor the c designated card number for the code and cc meet the conditions of the monster f fusion material",
        "text": "AddFusionProcCodeFun",
        "ret": ""
      },
      {
        "args": [
          "f"
        ],
        "desc": "aux.FilterBoolFunction(f: function, a, b, c)\n\nReturn function (target)\nReturn f (target, a, b, c)\nEnd",
        "text": "FilterBoolFunction",
        "ret": "function"
      },
      {
        "args": [
          "c",
          "filter"
        ],
        "desc": "aux.AddRitualProcGreater(c: Card, filter: function)\n\nAdd a ritual summon effect to c\nFilter for the ritual monster to meet the conditions, the material level can be more than the ritual monster level",
        "text": "AddRitualProcGreater",
        "ret": ""
      },
      {
        "args": [
          "c",
          "filter"
        ],
        "desc": "aux.AddRitualProcEqual(c: Card, filter: function)\n\nAdd a ritual summon effect to c\nFilter for the ritual monster to meet the conditions, the material level must be equal to the ritual monster level",
        "text": "AddRitualProcEqual",
        "ret": ""
      },
      {
        "args": [
          "c",
          "code1",
          "code2",
          "code3",
          "sub",
          "insf"
        ],
        "desc": "aux.AddFusionProcCode3(c: Card, code1: int, code2: int, code3: int, sub: boolean, insf: boolean)\n\nFor the c designated card number code1, code2, code3 monster for the fusion material",
        "text": "AddFusionProcCode3",
        "ret": ""
      },
      {
        "args": [
          "c",
          "f",
          "cc",
          "insf"
        ],
        "desc": "aux.AddFusionProcFunRep(c: Card, f: function, cc: int, insf: boolean)\n\nFor the c designated cc meet the same conditions f monster for the fusion material",
        "text": "AddFusionProcFunRep",
        "ret": ""
      }
    ],
    "cls": "aux"
  }
]
