[
  {
    "cls": "Card",
    "infer": "c",
    "methods": [
      {
        "id": "IsAttackAbove",
        "desc": "Check whether c is more than attack power atk",
        "argstr": "c: Card, atk: number",
        "args": [
          { "id": "c", "type": "Card" },
          { "id": "atk", "type": "number" }
        ],
        "ret": [ "boolean" ]
      },
      {
        "id": "GetCardTargetCount",
        "desc": "Returns the number of current persistent objects",
        "argstr": "c: Card",
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "ret": [ "number" ]
      },
      {
        "id": "GetBaseAttack",
        "desc": "Return the original attack power of c",
        "argstr": "c: Card",
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "ret": [ "number" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the type of card entry for c",
        "id": "GetOriginalType",
        "ret": [ "number" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the class before the c position changes",
        "id": "GetPreviousRankOnField",
        "ret": [ "number" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c is in an invalid state",
        "id": "IsDisabled",
        "ret": [ "boolean" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the deck of the card that fought this turn\nFighting has occurred in the calculation of the damage occurred, for the sword and other animals, animal judgments",
        "id": "GetBattledGroup",
        "ret": [ "Group" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the attributes of the card that c is describing",
        "id": "GetOriginalAttribute",
        "ret": [ "number" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" },
          { "id": "g", "opt": true, "type": "Group" },
          { "id": "gc", "opt": true, "type": "Card" },
          { "id": "chkf", "opt": true, "type": "number" }
        ],
        "argstr": "c: Card [, g: Group, gc: Card | nil, chkf: number = PLAYER_NONE]",
        "desc": "Check if g contains a set of fusion material that c needs [must contain gc]",
        "id": "CheckFusionMaterial",
        "ret": [ "boolean" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" },
          { "id": "ac", "opt": true, "type": "number" },
          { "id": "monsteronly", "opt": true, "type": "boolean" }
        ],
        "argstr": "c: Card [, ac: number = 2, monsteronly: boolean = false]",
        "desc": "Check whether c can be a continuous attack, c the number of attacks declared> = ac return false\nNote: This function returns false when c has made multiple attacks due to effects such as flashing swords",
        "id": "IsChainAttackable",
        "ret": [ "boolean" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Return c as the fusion material when the card number (including the original c card number)",
        "id": "GetFusionCode",
        "ret": [ "number" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" },
          { "id": "status", "type": "number" }
        ],
        "argstr": "c: Card, status: number",
        "desc": "Check whether c contains a status code",
        "id": "IsStatus",
        "ret": [ "boolean" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the attack power recorded on card c",
        "id": "GetTextAttack",
        "ret": [ "number" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be liberated (non-superior call)",
        "id": "IsReleasable",
        "ret": [ "boolean" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the effect that causes the position of c to change",
        "id": "GetReasonEffect",
        "ret": [ "Effect" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the Battle Position of c before this battle occurs",
        "id": "GetBattlePosition",
        "ret": [ "number" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns c the current first persistent object",
        "id": "GetFirstCardTarget",
        "ret": [ "Card" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current set of cards",
        "id": "GetEquipGroup",
        "ret": [ "Group" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns all currently persistent objects",
        "id": "GetCardTarget",
        "ret": [ "Group" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" },
          { "id": "setname", "type": "number" }
        ],
        "argstr": "c: Card, setname: number",
        "desc": "Check the c as a fusion material can be used as a name setname card",
        "id": "IsFusionSetCard",
        "ret": [ "boolean" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the actual timestamp for the c transition to the current position\nOpening the card from the inside does not change this value",
        "id": "GetRealFieldID",
        "ret": [ "number" ]
      },
      {
        "args": [
          { "id": "c", "type": "Card" },
          { "id": "reset_code", "type": "number" },
          { "id": "reset_type", "type": "number" }
        ],
        "argstr": "c: Card, reset_code: number, reset_type: number",
        "desc": "To reset the type to reset_type, reset the type reset_code manual reset c impact of the impact\nThe reset_type can only be one of the following types, and the corresponding reset type is\nRESET_EVENT An event reset_code is set for the event\nRESET_PHASE End of phase Reset the reset_code to phase\nRESET_CODE reset the effect of the specified code reset_code for the type of effect code, can only be reset EFFECT_TYPE_SINGLE sustainable type effect\nRESET_COPY resets the effect of the copy. Reset_code is copy_id\nRESET_CARD The effect of resetting the card reset_code is the card number of the effect owner",
        "id": "ResetEffect"
      },
      {
        "args": [
          { "id": "c", "type": "Card" }
        ],
        "argstr": "c: Card",
        "desc": "Returns the destination of an effect (such as the universe) that was changed as a result of departure from c",
        "id": "GetLeaveFieldDest",
        "ret": [ "number" ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the controller before the position change of c",
        "id": "GetPreviousControler",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "location",
            "type": "number"
          }
        ],
        "argstr": "c: Card, location: number",
        "desc": "Check if c is the current location\nNote: When the monster summon, reverse call, call special summon before the success,\nAnd location = LOCATION_MZONE, this function returns false",
        "id": "IsLocation",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be sent as an additional cost card group",
        "id": "IsAbleToExtraAsCost",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "c: Card, g: Group",
        "desc": "The g of all the cards as the c material (superior summon, special summon)",
        "id": "SetMaterial"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the holder of c",
        "id": "GetOwner",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the material used for the appearance of c",
        "id": "GetMaterial",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "fc",
            "type": "Card"
          }
        ],
        "argstr": "c: Card, fc: Card",
        "desc": "Check whether the c can replace the material description card name of the fusion monster fc",
        "id": "CheckFusionSubstitute",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Clear all the effects of c contact",
        "id": "ClearEffectRelation"
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          }
        ],
        "argstr": "c1: Card, c2: Card",
        "desc": "Cancel c2 as a perpetual object of c1",
        "id": "CancelCardTarget"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the number of cards currently stacked",
        "id": "GetOverlayCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "countertype",
            "type": "number"
          }
        ],
        "argstr": "c: Card, countertype: number",
        "desc": "Returns the number of countertype types on c",
        "id": "GetCounter",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the number of times this declaration was asserted\nNote: Attack is invalid will not count the number of attacks, but will be counted into the number of attacks on the Declaration",
        "id": "GetAttackAncountCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the code number of the card in c",
        "id": "GetOriginalCode",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the time stamp of the transition to the current position\nThis value is unique, the smaller the c is the earlier appear in that position\nOpening the card from the inside will also change this value",
        "id": "GetFieldID",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Add a limit to the cs for c",
        "id": "EnableReviveLimit"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current codename for c (possibly because the effect changes)",
        "id": "GetCode",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          }
        ],
        "argstr": "c1: Card, c2: Card",
        "desc": "Check whether c1 and c2 are linked",
        "id": "IsRelateToCard",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current class of c",
        "id": "GetRank",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the rank before the c position change",
        "id": "GetPreviousLevelOnField",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "c: Card, player: number, min: number, max: number, reason: number",
        "desc": "For reason reason, let players player remove c stacked min-max card, the return value that is successful",
        "id": "RemoveOverlayCard",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the number of cards that take c as the persistent object",
        "id": "GetOwnerTargetCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "c: Card, e: Effect",
        "desc": "Check whether c is associated with effect e\nNote: Each launch into the effect of chain, the effect of launching the card, and the effect of the specified object\n(With Duel.SetTargetCard or Duel.SelectTarget specified, including the take and not take objects)",
        "id": "IsRelateToEffect",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be liberated by the effect",
        "id": "IsReleasableByEffect",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "rank",
            "type": "number"
          }
        ],
        "argstr": "c: Card, rank: number",
        "desc": "Check whether c is below the rank rank (at least 1)",
        "id": "IsRankBelow",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c is in the re-call state",
        "id": "IsDualState",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the defensive power before the c position changes",
        "id": "GetPreviousDefenseOnField",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "c: Card, e: Effect",
        "desc": "For the card c and the effect of e to establish contact",
        "id": "CreateEffectRelation"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "xyzc",
            "type": "Card"
          },
          {
            "id": "lv",
            "type": "number"
          }
        ],
        "argstr": "c: Card, xyzc: Card, lv: number",
        "desc": "Check c for excess monster xyzc with the level of whether the excess is lv",
        "id": "IsXyzLevel",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the currently stacked deck",
        "id": "GetOverlayGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "ignore_field",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "c: Card [, ignore_field: boolean = false]",
        "desc": "Check whether c can be set to the magic trap area, ignore_field = true is disregard of the trap area trap trap",
        "id": "IsSSetable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          }
        ],
        "argstr": "c1: Card, c2: Card",
        "desc": "Check whether c2 is the correct equipment object for c1",
        "id": "CheckEquipTarget",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "sc",
            "type": "Card"
          }
        ],
        "argstr": "c: Card, sc: Card",
        "desc": "Return to the co-ordination of c with the call monster sc with the level\nThis function returns the same value as Card.GetLevel (c) except for certain cards such as modems.",
        "id": "GetSynchroLevel",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Return c The round to the current position",
        "id": "GetTurnID",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "state",
            "type": "number"
          },
          {
            "id": "enable",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, state: number, enable: boolean",
        "desc": "Set or cancel the status code for c\nDo not use this function unless you clearly understand the meaning of each status code",
        "id": "SetStatus"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the card that caused the position of c to change\nThis function is only valid when a card is destroyed by a battle, because the superior call is released, or becomes a special call to use the material",
        "id": "GetReasonCard",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "countertype",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "singly",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, countertype: number, count: number [, singly: number = false]",
        "desc": "Check if c can place count counters of type countertype [singly = true]",
        "id": "IsCanAddCounter",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "player",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card [, player: number]",
        "desc": "Check whether c can be player except player",
        "id": "IsAbleToRemove",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the destination of the c position change\nThis function is valid only when processing position transitions instead of effects",
        "id": "GetDestination",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c is a card that can be called normally",
        "id": "IsSummonableCard",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the codename on the c rule (used as a card rule on this card)",
        "id": "GetOriginalCodeRule",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the device object before c",
        "id": "GetPreviousEquipTarget",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "forced",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, e: Effect [, forced: boolean = false]",
        "desc": "Register the effect e to c, return the global id of the effect, and set the Handler of e to c\nBy default, if c is registered with the effect of immune e then the registration will fail\nIf forced is true, the immune effect of c against e will not be checked",
        "id": "RegisterEffect",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "neglect_con",
            "type": "boolean"
          },
          {
            "id": "neglect_cost",
            "type": "boolean"
          },
          {
            "id": "copy_info",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, neglect_con: boolean, neglect_cost: boolean, copy_info: boolean",
        "desc": "Return to the timing of the launch of the correct c \"card launch\" effect, ignored_con = true ignoring the launch conditions, ignored_cost = true ignoring the launch cost\nCopy_info = false or the free-time effect only returns the effect\nOtherwise return the effect of the time point for the code when the trigger point information eg, ep, ev, re, r, rp",
        "id": "CheckActivateEffect",
        "ret": [
          "Effect"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "attribute",
            "type": "number"
          },
          {
            "id": "race",
            "type": "number"
          },
          {
            "id": "level",
            "type": "number"
          },
          {
            "id": "atk",
            "type": "number"
          },
          {
            "id": "def",
            "type": "number"
          }
        ],
        "argstr": "c: Card, attribute: number, race: number, level: number, atk: number, def: number",
        "desc": "Add the monster value to the trap card\nNote: Values ​​recorded in the database are treated as the original value, and are set to zero here",
        "id": "AddMonsterAttribute"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the sequence number before the c position changes",
        "id": "GetPreviousSequence",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the original right pendulum scale of c",
        "id": "GetOriginalRightScale",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the original left-hand pendulum scale of c",
        "id": "GetOriginalLeftScale",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "assume_type",
            "type": "number"
          },
          {
            "id": "assume_value",
            "type": "number"
          }
        ],
        "argstr": "c: Card, assume_type: number, assume_value: number",
        "desc": "Use the value of assume_type c as assume_value (genome fighter)\nAssume_type is the following type\nASSUME_CODE card number\nThe ASSUME_TYPE type\nASSUME_LEVEL class\nASSUME_RANK class\nASSUME_ATTRIBUTE property\nASSUME_RACE race\nASSUME_ATTACK Attack power\nASSUME_DEFENSE Defense",
        "id": "AssumeProperty"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "check_player",
            "type": "number"
          }
        ],
        "argstr": "c: Card, check_player: number",
        "desc": "Check the uniqueness of c in the check_player field",
        "id": "CheckUniqueOnField",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "unique_code",
            "type": "number"
          },
          {
            "id": "unique_location",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, s: number, o: number, unique_code: number [, unique_location: number = LOCATIOIN_ONFIELD]",
        "desc": "Set c to unique_code only in the field [or monster area or magic trap area, determined by the unique_location] can only exist one\nS is not 0 will check the uniqueness of their field, o is not 0 check the other field uniqueness",
        "id": "SetUniqueOnField"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "level",
            "type": "number"
          }
        ],
        "argstr": "c: Card, level: number",
        "desc": "Check whether c is below the level level (at least 1)",
        "id": "IsLevelBelow",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the number of times this round has been attacked\nNote: If this value is different from the return value of the previous function, then this card has been a direct attack this round",
        "id": "GetAttackedCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "type",
            "type": "number"
          },
          {
            "id": "value",
            "type": "number"
          }
        ],
        "argstr": "c: Card, type: number, value: number",
        "desc": "Set the card prompt for type c to c\nType can only be the following value, the corresponding value type is\nCHINT_TURN Turns\nCHINT_CARD card id\nCHINT_RACE race\nCHINT_ATTRIBUTE property\nCHINT_NUMBER number\nCHINT_DESC Description",
        "id": "SetHint"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "sumtype",
            "type": "number"
          },
          {
            "id": "sumplayer",
            "type": "number"
          },
          {
            "id": "nocheck",
            "type": "boolean"
          },
          {
            "id": "nolimit",
            "type": "boolean"
          },
          {
            "id": "sumpos",
            "opt": true,
            "type": "number"
          },
          {
            "id": "target_player",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, e: Effect, sumtype: number, sumplayer: number, nocheck: boolean, nolimit: boolean [, sumpos: number = POS_FACEUP, target_player: number = sumplayer]",
        "desc": "Check whether c can be sumplayer with the effect of the player e to sumtype form sumpos special summon to target_player field\nIf nocheck is true, the call condition of c is not checked, and if nolimit is true, then the limit of c is not checked",
        "id": "IsCanBeSpecialSummoned",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "reason",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "Card [, reason: number = REASON_COST]",
        "desc": "Check whether c can be discarded\nNote: This function is only used to detect,\nREASON_DISCARD as a reason to hand a card to the tomb and will not lead to that card can not be discarded",
        "id": "IsDiscardable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "sc",
            "opt": true,
            "type": "Card"
          }
        ],
        "argstr": "c: Card [, sc: Card]",
        "desc": "Check whether c can serve as ritual monsters sc sacrifice",
        "id": "IsCanBeRitualMaterial",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the card that fought with c",
        "id": "GetBattleTarget",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "atk",
            "type": "number"
          }
        ],
        "argstr": "c: Card, atk: number",
        "desc": "Check whether c is attack power atk below (at least 0)",
        "id": "IsAttackBelow",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the minimum and maximum number of sacrifices required to normally call c",
        "id": "GetTributeRequirement",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "c: Card, player: number, count: number, reason: number",
        "desc": "Check the player player can be reason for the reason, at least remove the c stacked count cards",
        "id": "CheckRemoveOverlayCard",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "extra_type",
            "type": "number"
          }
        ],
        "argstr": "c: Card, extra_type: number",
        "desc": "So trap the trap monster c to occupy a magic trap grid, and add the extra_type monster type\nNote: The Trap Monster attribute refers to both the monster and the trap at the same time, and an extra trap that makes a magic trap can not be used",
        "id": "TrapMonsterComplete"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check if c can send extra cards\nThis function returns false for non-fusion, cohomology, and overdrive cards",
        "id": "IsAbleToExtra",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current controller of c",
        "id": "GetControler",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          }
        ],
        "argstr": "c1: Card, c2: Card",
        "desc": "Check whether c1 can become a target of c2",
        "id": "IsCanBeBattleTarget",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "c: Card, e: Effect",
        "desc": "Check whether c can be the object of effect e",
        "id": "IsCanBeEffectTarget",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the call / special call of c",
        "id": "GetSummonType",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "c: Card, e: Effect",
        "desc": "Check whether c immune effect e (that is not affected by the impact of e)",
        "id": "IsImmuneToEffect",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Set c to re-call state",
        "id": "EnableDualState"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the round counter for c",
        "id": "GetTurnCounter",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "sc",
            "type": "Card"
          }
        ],
        "argstr": "c: Card, sc: Card | nil",
        "desc": "Check whether c can become an excessive monster sc excess material",
        "id": "IsCanBeXyzMaterial",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          }
        ],
        "argstr": "c1: Card, c2: Card",
        "desc": "Check whether c1 takes c2 as a persistent object",
        "id": "IsHasCardTarget",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current type of c",
        "id": "GetType",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the rank of the card in c",
        "id": "GetOriginalLevel",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be sent as a cost card group or additional card group (for the new Yu-xia, sword fighting beast fusion call monster detection procedures)",
        "id": "IsAbleToDeckOrExtraAsCost",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the card number prior to the c position change",
        "id": "GetPreviousCodeOnField",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "fc",
            "opt": true,
            "type": "Card"
          },
          {
            "id": "ignore_mon",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "c: Card [, fc: Card, ignore_mon: boolean = false]",
        "desc": "Check whether c can become a [fusion monster fc] fusion material, ignore_mon = true does not check whether c is a monster",
        "id": "IsCanBeFusionMaterial",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the type before the c position change",
        "id": "GetPreviousTypeOnField",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "level",
            "type": "number"
          }
        ],
        "argstr": "c: Card, level: number",
        "desc": "Check whether c is above level level",
        "id": "IsLevelAbove",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Set c to a monster that can not normally be called",
        "id": "EnableUnsummonable"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "setname",
            "type": "number"
          }
        ],
        "argstr": "c: Card, setname: number",
        "desc": "Check whether c is a card with the name setname",
        "id": "IsSetCard",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can turn into the inside of that",
        "id": "IsCanTurnSet",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current defense of c, the return value is negative that is \"?\"",
        "id": "GetDefense",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "countertype",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "c: Card, countertype: number, count: number",
        "desc": "Set c to place the upper limit of countertype type counters",
        "id": "SetCounterLimit"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "countertype",
            "type": "number"
          },
          {
            "id": "location",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, countertype: number [, location: number]",
        "desc": "Allow c [to be placed in the location location] that can be placed \"can be placed on the counter countertype\nThe default value of location depends on the type of c, and the monster needs to specify whether it can place a pointer in a monster or pendulum area",
        "id": "EnableCounterPermit"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "countertype",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "c: Card, player: number, countertype: number, count: number, reason: number",
        "desc": "Let the player player remove count counters of type c on c with reason",
        "id": "RemoveCounter"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current attribute of c\nNote: For some multi-attribute monsters such as light and dark dragon, the return value of this function may be a combination of several properties of the value",
        "id": "GetAttribute",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "sc",
            "opt": true,
            "type": "Card"
          },
          {
            "id": "tuner",
            "opt": true,
            "type": "Card"
          }
        ],
        "argstr": "c: Card [, sc: Card, tuner: Card]",
        "desc": "Check whether c can become a homophonic homophonic monster sc material",
        "id": "IsCanBeSynchroMaterial",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "ignore_count",
            "type": "boolean"
          },
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "min",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, ignore_count: boolean, e: Effect | nil [, min: number = 0]",
        "desc": "Check whether c is usually called (not including the normally called set), ignore_count = true does not check the number of calls limit\nE ~ = nil check whether c can be the effect of e is usually called, min said at least the number of sacrifice (used to distinguish between compromise summons and superior call)",
        "id": "IsSummonable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c is in the declaration prohibition state",
        "id": "IsForbidden",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "reset_flag",
            "type": "number"
          },
          {
            "id": "property",
            "type": "number"
          },
          {
            "id": "reset_count",
            "type": "number"
          },
          {
            "id": "label",
            "opt": true,
            "type": "number"
          },
          {
            "id": "desc",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number, reset_flag: number, property: number, reset_count: number [, label: number, desc: number]",
        "desc": "For the registration of a logo with the results\nNote: The effect of the registration to the card is not used for the system,\nEven if the code and the built-in effect code coincidence will not affect,\nAnd the type is always EFFECT_TYPE_SINGLE, reset method, property, and the general effect of the same,\nAnd will not be invalidated, immune effect from the card",
        "id": "RegisterFlagEffect",
        "ret": [
          "Effect"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "attribute",
            "type": "number"
          }
        ],
        "argstr": "c: Card, attribute: number",
        "desc": "Check whether c belongs to attribute attribute",
        "id": "IsAttribute",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check if c is open",
        "id": "IsPublic",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "def",
            "type": "number"
          }
        ],
        "argstr": "c: Card, def: number",
        "desc": "Check c is defensive def above",
        "id": "IsDefenseAbove",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the serial number of the current position\nIn the field, the sequence number on behalf of the grid, from left to right are 0-4, the venue magic number is 5, left and right pendulum area is 6-7\nIn other places, the serial number represents the first card, the lowest card number is 0",
        "id": "GetSequence",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          },
          {
            "id": "reset_flag",
            "type": "number"
          }
        ],
        "argstr": "c1: Card, c2: Card, reset_flag: number",
        "desc": "For c1 established in c2 contact this contact, only because c1 occurred RESET_EVENT the event reset",
        "id": "CreateRelation"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the race before the c position changes",
        "id": "GetPreviousRaceOnField",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the player that caused the position of c to change",
        "id": "GetReasonPlayer",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "pos",
            "type": "number"
          }
        ],
        "argstr": "c: Card, pos: number",
        "desc": "Check whether the c position before the change is represented by pos",
        "id": "IsPreviousPosition",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check if you can make a special call to c",
        "id": "IsSpecialSummonable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "def",
            "type": "number"
          }
        ],
        "argstr": "c: Card, def: number",
        "desc": "Check whether c is defensive def below (at least 0)",
        "id": "IsDefenseBelow",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "chainc",
            "type": "number"
          }
        ],
        "argstr": "c: Card, chainc: number",
        "desc": "Check if c is linked to chained chainc\nNote: Each launch into the effect of chain, the effect of launching the card, and the effect of the specified object\n(With Duel.SetTargetCard or Duel.SelectTarget specified, including the take and not take objects)\nWill automatically establish contact with that effect, once the departure, contact will be reset",
        "id": "IsRelateToChain",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the class of the card in c",
        "id": "GetOriginalRank",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "countertype",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "c: Card, player: number, countertype: number, count: number, reason: number",
        "desc": "Check if the player player can remove count counters of type c on c for reason",
        "id": "IsCanRemoveCounter",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "location",
            "type": "number"
          }
        ],
        "argstr": "c: Card, location: number",
        "desc": "Check if the location before c is location",
        "id": "IsPreviousLocation",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current artefact object",
        "id": "GetEquipTarget",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "controler",
            "type": "number"
          }
        ],
        "argstr": "c: Card, controler: number",
        "desc": "Check whether the current control of c is a controler",
        "id": "IsControler",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "pos",
            "type": "number"
          }
        ],
        "argstr": "c: Card, pos: number",
        "desc": "Check whether c is in the Battle Position pos",
        "id": "IsPosition",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "c: Card, reason: number",
        "desc": "Check if c contains the reason",
        "id": "IsReason",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number",
        "desc": "Manually clear the type of c is the code of the identification effect",
        "id": "ResetFlagEffect"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Return the c 's card record of the garrison",
        "id": "GetTextDefense",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the Battle Position of c before position changes",
        "id": "GetPreviousPosition",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c is an attack",
        "id": "IsAttackPos",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the position before the c position changes",
        "id": "GetPreviousLocation",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c is face-up",
        "id": "IsFaceup",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "c: Card, e: Effect",
        "desc": "Manually release the link between c and effect e",
        "id": "ReleaseEffectRelation"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can attack",
        "id": "IsAttackable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the attackable card set and whether it can attack directly",
        "id": "GetAttackableTarget",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be excluded as a cost",
        "id": "IsAbleToRemoveAsCost",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "label",
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number, label: number",
        "desc": "Returns whether or not c has an identifier of type code, and sets its Label property to label",
        "id": "SetFlagEffectLabel",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "ignore_count",
            "type": "boolean"
          },
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "min",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "Card, ignore_count: boolean, e: Effect | nil [, min: number = 0]",
        "desc": "Check whether c can be normally called set, ignore_count = true does not check the number of calls limit\nE ~ = nil then check whether c can be the effect of e is usually called set, min that at least the number of sacrifices needed (used to distinguish between compromise summoned set and superior summoned set)",
        "id": "IsMSetable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be sent to the cemetery as a cost",
        "id": "IsAbleToGraveAsCost",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number",
        "desc": "Check if c is affected by the effect type",
        "id": "IsHasEffect",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be sent as the cost of hand cards\nNote: This function appends the actual destination of c to Card.IsAbleToHand\nThis function returns false when c is sent to the other hand (if the retraction loop is applicable, or c is a blend, cohomology, and oversize)",
        "id": "IsAbleToHandAsCost",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be sent to the cemetery",
        "id": "IsAbleToGrave",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the number of cards battled for this turn",
        "id": "GetBattledGroupCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can hand\nNote: This function returns false only if the card or player is affected by the effect of being unable to join the hand (such as Ray King)",
        "id": "IsAbleToHand",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can change the control\nNote: This function returns false only if the card receives the effect of \"Can not change control\"",
        "id": "IsAbleToChangeControler",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "mg",
            "type": "Group"
          }
        ],
        "argstr": "c: Card, mg: Group | nil [, min = 0, max = 0]",
        "desc": "Check whether mg can be selected in the [min-max months] excessive material on the c to call the excess procedure\nIf mg is nil, this function has the same effect as Card.IsSpecialSummonable",
        "id": "IsXyzSummonable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "tuner",
            "type": "Card"
          },
          {
            "id": "mg",
            "opt": true,
            "type": "Group"
          }
        ],
        "argstr": "c: Card, tuner: Card | nil [, mg: Group]",
        "desc": "Check whether tuner can be used as an adjustment, the field card [or mg] for the coherent material on the c cohomology summon procedures\nIf the tuner is nil, this function has the same effect as Card.IsSpecialSummonable",
        "id": "IsSynchroSummonable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "spsummon_code",
            "type": "number"
          }
        ],
        "argstr": "c: Card, spsummon_code: number",
        "desc": "Set c can only be a round of a special call (they reveal, wave dragon)\nThe same spsummon_code shares 1 number of times",
        "id": "SetSPSummonOnce"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "cancel",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "c: Card [, cancel: boolean = true]",
        "desc": "Cancel to send to determine the state tomb, cancel = false to reset the tomb to determine the state\nNote: to send the tomb to determine the state refers to the field to start without leaving field magic and traps, the state of these cards\nCards sent to the tomb determine the state can not return cards and cards, and sent to the cemetery at the end of the chain\nThe purpose of this function is to cancel this state to stay in the field, for the light of the sword and seal the Scarlet Scarlet card",
        "id": "CancelToGrave"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the left-hand pendulum scale of c",
        "id": "GetLeftScale",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current level of c",
        "id": "GetLevel",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "reset_flag",
            "type": "number"
          },
          {
            "id": "reset_count",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number, reset_flag: number [, reset_count: number]",
        "desc": "Replace the effect of c with the effect of the card whose card number is code, and add additional reset conditions\nThe return value is the code id representing the replacement effect",
        "id": "ReplaceEffect",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "reset_flag",
            "type": "number"
          },
          {
            "id": "reset_count",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number, reset_flag: number [, reset_count: number]",
        "desc": "Adding a card number for c is the replicable effect of the card's code, and adding an additional reset condition\nThe return value is the code id representing the copy effect",
        "id": "CopyEffect",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "rc",
            "type": "Card"
          }
        ],
        "argstr": "c: Card, rc: Card",
        "desc": "Returns the ritual liberation level for rc ritual monsters\nThis function returns the same value as Card.GetLevel (c) except for certain cards such as ritual objects",
        "id": "GetRitualLevel",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c is associated with this battle\nNote: This effect is usually used for damage calculation before the end of the injury phase, used to check whether the fighting off the card too",
        "id": "IsRelateToBattle",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "rank",
            "type": "number"
          }
        ],
        "argstr": "c: Card, rank: number",
        "desc": "Check whether c is above the class rank",
        "id": "IsRankAbove",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number",
        "desc": "The type of c is the label that identifies the effect of code, and returns nil if it does not",
        "id": "GetFlagEffectLabel",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          }
        ],
        "argstr": "c1: Card, c2: Card",
        "desc": "Manually release c1 for c2",
        "id": "ReleaseRelation"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c is face-down",
        "id": "IsFacedown",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be sent to the card group",
        "id": "IsAbleToDeck",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number",
        "desc": "Returns the number of effects that c is affected by the type of code",
        "id": "GetEffectCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be sent to the card as a cost group",
        "id": "IsAbleToDeckAsCost",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code1",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card [, code1: number, ...]",
        "desc": "Reset c affected by the effect of cards whose card number is code1, code2 ...",
        "id": "ResetNegateEffect"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c direct attack",
        "id": "IsDirectAttacked",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "countertype",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "singly",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, countertype: number, count: number [, singly: number = false]",
        "desc": "Place count count counter type c for c, singly true to add one to the upper limit",
        "id": "AddCounter",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number",
        "desc": "Check the c as a fusion material can be used as the card number for the code card",
        "id": "IsFusionCode",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Return to Summoner / Special Summoner c Players",
        "id": "GetSummonPlayer",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the number of ally cards for the current device",
        "id": "GetUnionCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the card set attacked by this turn",
        "id": "GetAttackedGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the attack power before the c position changes",
        "id": "GetPreviousAttackOnField",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the number of cards currently loaded",
        "id": "GetEquipCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current position of c",
        "id": "GetLocation",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether the control of c can be changed\nNote: This function appends the space on the field to the Card.IsAbleToChangeControler",
        "id": "IsControlerCanBeChanged",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the position change reason for c",
        "id": "GetReason",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          }
        ],
        "argstr": "c1: Card, c2: Card",
        "desc": "C2 as the perpetual object of c1\nC1 and c2 of the contact will c1 or c2 any one card to leave or become the side of that reset",
        "id": "SetCardTarget"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the number of cards that have been attacked this turn",
        "id": "GetAttackedGroupCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "c: Card, code: number",
        "desc": "The type of returned c is the number of identifying effects of the code",
        "id": "GetFlagEffect",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "The setting c is indicated in the front of the deck",
        "id": "ReverseInDeck"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns all cards with c as the persistent object",
        "id": "GetOwnerTarget",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "e",
            "opt": true,
            "type": "Effect"
          }
        ],
        "argstr": "c: Card [, e: Effect]",
        "desc": "Check whether c is destructible",
        "id": "IsDestructable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the effect of the \"card firing\" of c, that is, the effect of type EFFECT_TYPE_ACTIVATE\nOnly for magic and traps",
        "id": "GetActivateEffect",
        "ret": [
          "Effect"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "setname",
            "type": "number"
          }
        ],
        "argstr": "c: Card, setname: number",
        "desc": "Check whether the name c contains a setname before the c position changes",
        "id": "IsPreviousSetCard",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check if c is present\nNote: This function returns false when the monster summons, reverses the call, and when the summon is successful",
        "id": "IsOnField",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the amount of material used for c appearance",
        "id": "GetMaterialCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "counter",
            "type": "number"
          }
        ],
        "argstr": "c: Card, counter: number",
        "desc": "Set c of the round counter (light of the sword, etc.)",
        "id": "SetTurnCounter"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c can be used as a non-adjustment",
        "id": "IsNotTuner",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Check whether c is in Defense Position",
        "id": "IsDefensePos",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "race",
            "type": "number"
          }
        ],
        "argstr": "c: Card, race: number",
        "desc": "Check if c is race race",
        "id": "IsRace",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "type",
            "type": "number"
          }
        ],
        "argstr": "c: Card, type: number",
        "desc": "Check if c is of type type",
        "id": "IsType",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code1",
            "type": "number"
          },
          {
            "id": "code2",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, code1: number [, code2: number, ...]",
        "desc": "Check whether the card number c is code1 [, or code2 ...]",
        "id": "IsCode",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the call position of c",
        "id": "GetSummonLocation",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the attribute before the c position change",
        "id": "GetPreviousAttributeOnField",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Return the current attack power of c, the return value is a negative that is \"?\"",
        "id": "GetAttack",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current Battle Position of c",
        "id": "GetPosition",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Return to the original c of the defense",
        "id": "GetBaseDefense",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the c of the card record race",
        "id": "GetOriginalRace",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the current race of c\nNote: For some multi-ethnic monsters such as animation effects of the magic ape, the function of the return value may be a combination of several racial values",
        "id": "GetRace",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the right-hand pendulum scale of c",
        "id": "GetRightScale",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the card with c as the excess material",
        "id": "GetOverlayTarget",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "So that c to complete the formal call procedures",
        "id": "CompleteProcedure"
      }
    ]
  },
  {
    "cls": "Effect",
    "infer": "e",
    "methods": [
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "playerid",
            "type": "number"
          },
          {
            "id": "s_range",
            "type": "number"
          },
          {
            "id": "o_range",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, playerid: number, s_range: number, o_range: number",
        "desc": "Set the target range property and set the EFFECT_FLAG_ABSOLUTE_RANGE flag\nPlayerid! = 0 s_range and o_range invert",
        "id": "SetAbsoluteRange"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "s_time",
            "type": "number"
          },
          {
            "id": "o_time",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "e: Effect, s_time: number [, o_time: number = s_time]",
        "desc": "Set the prompt point",
        "id": "SetHintTiming"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Gets the id of the effect e",
        "id": "GetFieldID",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "cate",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, cate: number",
        "desc": "Set the Category property",
        "id": "SetCategory"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "The effect of e reset, reset can not be used after this effect",
        "id": "Reset"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "prop1",
            "type": "number"
          },
          {
            "id": "prop2",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "e: Effect, prop1: number [, prop2: number]",
        "desc": "Set the Property property",
        "id": "SetProperty"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "desc",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, desc: number",
        "desc": "Sets the effect description for effect e",
        "id": "SetDescription"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, player: number",
        "desc": "Check whether the effect can be launched by the player",
        "id": "IsActivatable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the Category property",
        "id": "GetCategory",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the Type property",
        "id": "GetType",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "player",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "e: Effect [, player: number]",
        "desc": "Set the OwnerPlayer property to player",
        "id": "SetOwnerPlayer"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, code: number",
        "desc": "Set the Code property for effect e",
        "id": "SetCode"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "range",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, range: number",
        "desc": "Set the Range property for effect e",
        "id": "SetRange"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "type",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, type: number",
        "desc": "Set the Type property for effect e",
        "id": "SetType"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "reset_flag",
            "type": "number"
          },
          {
            "id": "reset_count",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "e: Effect, reset_flag: number [, reset_count: number = 1]",
        "desc": "Set the reset parameter",
        "id": "SetReset"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the firing area of ​​the effect e",
        "id": "GetActivateLocation",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Check the effect of e is the effect of starting (chassis)",
        "id": "IsActivated",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "type",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, type: number",
        "desc": "Check if the effect is of type `type`",
        "id": "IsHasType",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the value attribute",
        "id": "GetValue",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Create a new copy of effect e",
        "id": "Clone",
        "ret": [
          "Effect"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the card on which the effect takes effect (usually a card that registers the effect with Card.RegisterEffect)",
        "id": "GetHandler",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "cate",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, cate: number",
        "desc": "Check whether the effect contains cate",
        "id": "IsHasCategory",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the effect type of e (monster, magic, trap)\nAnd launch the effect of the type of card is not necessarily the same, such as the spirit of pendulum effect as a magic card effect",
        "id": "GetActiveType",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "prop1",
            "type": "number"
          },
          {
            "id": "prop2",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "e: Effect, prop1: number [, prop2: number]",
        "desc": "Check if the effect contains the flags prop1 [and prop2]",
        "id": "IsHasProperty",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "cost_func",
            "type": "function"
          }
        ],
        "argstr": "e: Effect, cost_func: function",
        "desc": "Set the Cost property",
        "id": "SetCost"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "type",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, type: number",
        "desc": "Check if the effect type of e (monster, magic, trap) has a type",
        "id": "IsActiveType",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [],
        "desc": "Create a new global effect",
        "id": "GlobalEffect",
        "ret": [
          "Effect"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the OwnerPlayer property, which is typically the controller of the Owner",
        "id": "GetOwnerPlayer",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "con_func",
            "type": "function"
          }
        ],
        "argstr": "e: Effect, con_func: function",
        "desc": "Set the Condition property",
        "id": "SetCondition"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Create a new empty effect\nAnd the owner of the effect is c",
        "id": "CreateEffect",
        "ret": [
          "Effect"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "val",
            "type": "function"
          }
        ],
        "argstr": "e: Effect, val: function | int | boolean",
        "desc": "Set the Value property",
        "id": "SetValue"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the operation attribute",
        "id": "GetOperation",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the cost attribute",
        "id": "GetCost",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Return to the current, usually Handle controller",
        "id": "GetHandlerPlayer",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the condition property",
        "id": "GetCondition",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the Label property",
        "id": "GetLabel",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "op_func",
            "type": "function"
          }
        ],
        "argstr": "e: Effect, op_func: function",
        "desc": "Set the Operation property",
        "id": "SetOperation"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the LabelObject property",
        "id": "GetLabelObject",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the Owner property",
        "id": "GetOwner",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the target attribute",
        "id": "GetTarget",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the code property",
        "id": "GetCode",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "labelobject",
            "type": "Card"
          }
        ],
        "argstr": "e: Effect, labelobject: Card | Group | Effect",
        "desc": "Sets the LabelObject property",
        "id": "SetLabelObject"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "s_range",
            "type": "number"
          },
          {
            "id": "o_range",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, s_range: number, o_range: number",
        "desc": "Set the Target Range property for effect e\nS_range refers to our area of ​​influence\nThe o_range value affects the partner area\nIf the EFFECT_FLAG_ABSOLUTE_RANGE flag is specified in the property property,\nThen s_range refers to the player 1 affected area, o_range refers to player 2 affected area\nIf this is a call (cover) / limit call (cover) / special call procedure\n(EFFECT_SUMMON_PROC / EFFECT_LIMIT_SUMMON_PROC / EFFECT_SPSUMMON_PROC, etc.)\nAnd the property specifies the EFFECT_FLAG_SPSUM_PARAM flag,\nThen s_range that special summoned to the players of the venue,\nO_range represents a selectable representation",
        "id": "SetTargetRange"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "targ_func",
            "type": "function"
          }
        ],
        "argstr": "e: Effect, targ_func: function",
        "desc": "Set the Target property",
        "id": "SetTarget"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "code",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "e: Effect, count: number [, code: number = 0]",
        "desc": "Set the number of times a round can be launched count (only trigger type effect is valid), the same code (not equal to 0 or 1) share a number of times\nThe code contains the following values ​​that have special properties\nEFFECT_COUNT_CODE_OATH The number of vows\nEFFECT_COUNT_CODE_DUEL The number of times in the duel\nEFFECT_COUNT_CODE_SINGLE the same card more than the number of public use of the effect (not the same name card)",
        "id": "SetCountLimit"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the Property property",
        "id": "GetProperty",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Returns the description of the effect",
        "id": "GetDescription",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "label",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, label: number",
        "desc": "Sets the Label property",
        "id": "SetLabel"
      }
    ]
  },
  {
    "cls": "Group",
    "infer": "g",
    "methods": [
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "g: Group, f: function, ...",
        "desc": "Calculates the sum of the values ​​of all cards in g, f is the value function for each card, starting with the third parameter as an additional parameter",
        "id": "GetSum",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "g: Group, f: function, ex: Card | nil, ...",
        "desc": "The filter function filters the card from g that satisfies the filter condition f and is not equal to ex\nStarting from the 4th parameter as an additional parameter",
        "id": "Filter",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "g: Group, f: function, ...",
        "desc": "F is a function that returns an interger value, and the card with the smallest value of f is selected from g\nThe second return value is the minimum value, starting at the third parameter as an additional parameter\nTo use the second return value Note Check g is not empty",
        "id": "GetMinGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Create a new copy of card group g",
        "id": "Clone",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Let the deck continue, set the deck to effect LabelObject needs to be set",
        "id": "KeepAlive"
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "g: Group, player: number, f: function, min: number, max: number, ex: Card | nil, ...",
        "desc": "Filter function, allowing players to choose from the g player min-max sheets meet the screening conditions f and not equal to the ex card\nStarting with the 7th argument is an additional parameter",
        "id": "FilterSelect",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "g: Group, f: function, ex: Card | nil, ...",
        "desc": "Remove all cards from g that satisfy the filter condition f and not equal to ex, the fourth parameter starts with the extra argument",
        "id": "Remove"
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "sum",
            "type": "number"
          }
        ],
        "argstr": "g: Group, player: number, f: function, sum: number, ...",
        "desc": "Let the player player select a subset from g so that the sum of the particular function f of the subset is greater than or equal to sum, starting at the fifth argument as an extra parameter",
        "id": "SelectWithSumGreater",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "g: Group, f: function, count: number, ex: Card | nil, ...",
        "desc": "Filter function to check if there is at least count of cards in g that satisfy the filter condition f and not equal to ex\nStarting from the 5th parameter as an additional parameter",
        "id": "IsExists",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "g1",
            "type": "Group"
          },
          {
            "id": "g2",
            "type": "Group"
          }
        ],
        "argstr": "g1: Group, g2: Group",
        "desc": "Combine all cards in g2 to g1\nNote: g2 itself does not change",
        "id": "Merge"
      },
      {
        "args": [
          {
            "id": "g1",
            "type": "Group"
          },
          {
            "id": "g2",
            "type": "Group"
          }
        ],
        "argstr": "g1: Group, g2: Group",
        "desc": "It is judged whether or not g1 and g2 are the same",
        "id": "Equal",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "g: Group, player: number, count: number",
        "desc": "Let the player player randomly select count cards from g\nBecause it is a random choice, so the basic parameter useless player, randomly selected by the system",
        "id": "RandomSelect",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "g: Group, f: function, ...",
        "desc": "Calculate the number of all cards in g, f is the basis of the classification, return the same value as the same category, starting from the first three parameters for additional parameters",
        "id": "GetClassCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "g: Group, f: function, ...",
        "desc": "Returns the first card in g that satisfies the filter condition f, starting at the third argument as an extra argument",
        "id": "SearchCard",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "g: Group, f: function, ...",
        "desc": "F is the function that returns an interger value, and the card with the largest value of f is selected from g\nThe second return value is the maximum value, starting with the third parameter as an additional parameter\nTo use the second return value Note Check g is not empty",
        "id": "GetMaxGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "g: Group, player: number, min: number, max: number, ex: Card | nil",
        "desc": "Let player player from g select the min-max Zhang is not equal to the ex card",
        "id": "Select",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [],
        "desc": "Creates an empty group of cards",
        "id": "CreateGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Returns the number of cards in g",
        "id": "GetCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "g: Group, f: function, ex: Card | nil, ...",
        "desc": "Filter function, and Group.Filter is basically the same, the difference is that this function only returns the number of cards to meet the conditions",
        "id": "FilterCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card [, ...]",
        "desc": "Indefinite parameters, the incoming card into a combination of all cards and return",
        "id": "FromCards",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Returns the first card in g and resets the current pointer to the first card in g\nReturns nil if card does not exist in g",
        "id": "GetFirst",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "g: Group, c: Card",
        "desc": "Check g for card c",
        "id": "IsContains",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "sum",
            "type": "number"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          }
        ],
        "argstr": "g: Group, f: function, sum: number, min: number, max: number, ...",
        "desc": "The subset summation decision function, f, is a function that returns an interger value\nCheck whether there is a subset of min-max in g that satisfies that the sum of the values ​​of each element of the subset f is equal to sum, starting at the 6th argument as an extra parameter\nFor example: g: CheckWithSumEqual (Card.GetSynchroLevel, 7,2,99)\nCheck if the sum of the same call levels in a subset of g satisfies a subset equal to 7",
        "id": "CheckWithSumEqual",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Point the pointer to the next card and return the card, or nil if it does not exist",
        "id": "GetNext",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "g1",
            "type": "Group"
          },
          {
            "id": "g2",
            "type": "Group"
          }
        ],
        "argstr": "g1: Group, g2: Group",
        "desc": "Remove the card from g1 that belongs to g2\nNote: g2 itself does not change",
        "id": "Sub"
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "sum",
            "type": "number"
          }
        ],
        "argstr": "g: Group, f: function, sum: number, ...",
        "desc": "The sum of the subsets is determined by a function f, which is a function that returns an interger value\nCheck that there is a subset in g that satisfies that the sum of the values ​​of each element of the subset f is just greater than or equal to sum, starting at the fourth argument as an extra parameter\nFor example: g: CheckWithSumGreater (Card.GetRitualLevel, 8)\nCheck if the sum of the ritual classes in g satisfies a subset of 8 or greater\nNote: The decision must be \"just\" greater than or equal to\nTo grade, for example, to make the total level is greater than or equal to 8, you can choose LV1 + LV7 and can not choose LV1 + LV4 + LV4",
        "id": "CheckWithSumGreater",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "g: Group, c: Card",
        "desc": "Add card c to group g",
        "id": "AddCard"
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "g: Group, f: function",
        "desc": "Call f once for each card in g as a parameter",
        "id": "ForEach"
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "sum",
            "type": "number"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          }
        ],
        "argstr": "g: Group, player: number, f: function, sum: number, min: number, max: number, ...",
        "desc": "Let the player player select a subset of min-max from g so that the sum of the specific functions of the subset is equal to sum, starting at the 7th argument as an extra parameter",
        "id": "SelectWithSumEqual",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Delete the card group g",
        "id": "DeleteGroup"
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "g: Group, c: Card",
        "desc": "Remove card c from group g",
        "id": "RemoveCard"
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Empty the deck",
        "id": "Clear"
      }
    ]
  },
  {
    "cls": "Debug",
    "methods": [
      {
        "args": [
          {
            "id": "equip_card",
            "type": "Card"
          },
          {
            "id": "target",
            "type": "Card"
          }
        ],
        "argstr": "equip_card: Card, target: Card",
        "desc": "Add equip_card to the target",
        "id": "PreEquip",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "msg",
            "type": "string"
          }
        ],
        "argstr": "msg: string",
        "desc": "A message box appears",
        "id": "ShowHint"
      },
      {
        "args": [
          {
            "id": "msg",
            "type": "any"
          }
        ],
        "argstr": "msg: any",
        "desc": "Displays the message",
        "id": "Message"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "sum_type",
            "type": "number"
          },
          {
            "id": "sum_location",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card, sum_type: number [, sum_location: number = 0]",
        "desc": "Set summon information for card c: Summarize with sum_type method (usually summoned, special summoned, etc.) [from sum_location]",
        "id": "PreSummon"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "counter_type",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "c: Card, counter_type: number, count: number",
        "desc": "Add count counters_type counters for c",
        "id": "PreAddCounter"
      },
      {
        "args": [
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "owner",
            "type": "number"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "location",
            "type": "number"
          },
          {
            "id": "seq",
            "type": "number"
          },
          {
            "id": "pos",
            "type": "number"
          },
          {
            "id": "proc",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "code: number, owner: number, player: number, location: number, seq: number, pos: number [, proc: boolean = false]",
        "desc": "Add a card, the card number for the card holder is set to owner, to represent the form of pos placed in the player's field is located in the location on the seq seq grid\nProc = true then lifted the Soviet students limit",
        "id": "AddCard",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "flag",
            "type": "number"
          }
        ],
        "argstr": "flag: number",
        "desc": "Start with the option flag\nFlag: DUEL_ATTACK_FIRST_TURN + DUEL_SIMPLE_AI",
        "id": "ReloadFieldBegin"
      },
      {
        "args": [
          {
            "id": "playerid",
            "type": "number"
          },
          {
            "id": "lp",
            "type": "number"
          },
          {
            "id": "startcount",
            "type": "number"
          },
          {
            "id": "drawcount",
            "type": "number"
          }
        ],
        "argstr": "playerid: number, lp: number, startcount: number, drawcount: number",
        "desc": "Set the player information, divided into lp, the initial hand card for the startcount Zhang, drawcount each round of pumping\nPlayerid below 0, top 1",
        "id": "SetPlayerInfo"
      },
      {
        "args": [
          {
            "id": "name",
            "type": "string"
          }
        ],
        "argstr": "name: string",
        "desc": "Set the name of the AI",
        "id": "SetAIName"
      },
      {
        "args": [],
        "desc": "Layout ends",
        "id": "ReloadFieldEnd"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "target",
            "type": "Card"
          }
        ],
        "argstr": "c: Card, target: Card",
        "desc": "The target selected as the perpetual object c",
        "id": "PreSetTarget"
      }
    ]
  },
  {
    "cls": "Duel",
    "methods": [
      {
        "args": [
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "player",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "code: number [, player: number = PLAYER_ALL]",
        "desc": "Check whether the player player is the source code of the venue code\nThe site code refers to the code of the venue card in effect, or the value of the effect of the venue change\nSource Player is the controller of the card in effect, or the controller of the Poseidon Witch, etc.",
        "id": "IsEnvironment",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "lv",
            "type": "number"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "mg",
            "opt": true,
            "type": "Group"
          }
        ],
        "argstr": "player: number, c: Card, f: function, lv: number, min: number, max: number [, mg: Group]",
        "desc": "Let the player player for the excess monster c [from the mg] to select the excess with the level of lv for the min-max meet the conditions of the stack f material",
        "id": "SelectXyzMaterial",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [],
        "desc": "Used to check if damage has been calculated during the damage phase",
        "id": "IsDamageCalculated",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "chainc: number, f: function",
        "desc": "The effect of the chain chainc processing function replaced by f, used to achieve \"the effect becomes\" effect",
        "id": "ChangeChainOperation"
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "f: function, player: number, s: number, o: number, count: number, ex: Card | nil, ...",
        "desc": "Filter function to check whether there is at least the specified number of positions to meet the filter conditions f and not equal ex\nAnd can become a card of an object that is currently being processed\nThe seventh argument starts as an extra parameter",
        "id": "IsExistingTarget",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "phase",
            "type": "number"
          },
          {
            "id": "reset_flag",
            "type": "number"
          },
          {
            "id": "reset_count",
            "type": "number"
          },
          {
            "id": "value",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "player: number, phase: number, reset_flag: number, reset_count: number [, value: number]",
        "desc": "Skip player phase phase player, and in a specific stage after reset, reset parameters and the same effect",
        "id": "SkipPhase"
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "f: function",
        "desc": "Function with Duel.SetChainLimit, but this function sets the chain until the end of the chain will be lifted",
        "id": "SetChainLimitTillChainEnd"
      },
      {
        "args": [],
        "desc": "Check the existence of the current chain of the same name card launch, true that no card with the same name",
        "id": "CheckChainUniqueness",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "desc",
            "type": "number"
          }
        ],
        "argstr": "player: number, desc: number",
        "desc": "Let player player select Yes or No",
        "id": "SelectYesNo",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "sel_player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "sel_player: number, f: function, player: number, s: number, o: number, min: number, max: number, ex: Card | nil, ...",
        "desc": "Filter function, so that player sel_player select the specified location to meet the filter condition f and not equal ex\nAnd can be the min-max card of the object that is currently processing the effect\nThe ninth parameter starts as an extra parameter\nThis function sets the currently locked object to the selected card at the same time",
        "id": "SelectTarget",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "hint_type",
            "type": "number"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "desc",
            "type": "number"
          }
        ],
        "argstr": "hint_type: number, player: number, desc: number",
        "desc": "Send hint_type to the player player type of message prompts, the contents of the prompt desc",
        "id": "Hint"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "f1",
            "type": "function"
          },
          {
            "id": "f2",
            "type": "function"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "smat",
            "opt": true,
            "type": "Card"
          },
          {
            "id": "mg",
            "opt": true,
            "type": "Group"
          }
        ],
        "argstr": "c: Card, f1: function, f2: function, min: number, max: number [, smat: Card, mg: Group]",
        "desc": "Check [mg] whether there is a group [must include smat] meet the conditions of the min-max cards as cohort calls c material\nF1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions",
        "id": "CheckSynchroMaterial",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Cut the card (magic hat) over the monster area",
        "id": "ShuffleSetCard"
      },
      {
        "args": [
          {
            "id": "c",
            "opt": true,
            "type": "Card"
          }
        ],
        "argstr": "[c: Card]",
        "desc": "Manually refreshing the card's inactive state on card [affected by card c]",
        "id": "AdjustInstantly"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "mg",
            "type": "Group"
          }
        ],
        "argstr": "player: number, c: Card, mg: Group | nil [, min = 0, max = 0]",
        "desc": "Let the player player [from the mg] [choose min-max a material] on the c to call the excess procedure\nMg is not empty and min is 0 mg directly to all the excess material",
        "id": "XyzSummon"
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          }
        ],
        "argstr": "c1: Card, c2: Card",
        "desc": "Salvation Star Dragon dedicated. Copy the effect described in c2 to c1\nForced to launch the effect can choose whether to launch",
        "id": "MajesticCopy"
      },
      {
        "args": [
          {
            "id": "sel_player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "sel_player: number, f: function, min: number, max: number, ex: Card | nil, ...",
        "desc": "Filter function, allowing players to choose from the field min-max Zhang is not equal to ex to meet the conditions f can be liberated card (non-superior summon)",
        "id": "SelectReleaseGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          },
          {
            "id": "category",
            "type": "number"
          }
        ],
        "argstr": "chainc: number, category: number",
        "desc": "Returns the operation information of the chained chainc category, with a return value of 5,\nThe first return value is false to indicate that the class does not exist\nThe last four return values ​​correspond to the last four parameters of Duel.SetOperationInfo: Card | Group targets, int count, int target_player, int target_param",
        "id": "GetOperationInfo",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "g",
            "type": "Group"
          },
          {
            "id": "gc",
            "opt": true,
            "type": "Card"
          },
          {
            "id": "chkf",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "player: number, c: Card, g: Group [, gc: Card | nil, chkf: number = PLAYER_NONE]",
        "desc": "Let the player player from the g to select a group [must contain gc] fusion fusion monster c material",
        "id": "SelectFusionMaterial",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "global_flag",
            "type": "number"
          }
        ],
        "argstr": "global_flag: number",
        "desc": "Set the global flag global_flag",
        "id": "EnableGlobalFlag"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "setcode",
            "opt": true,
            "type": "number"
          },
          {
            "id": "attack",
            "opt": true,
            "type": "number"
          },
          {
            "id": "defense",
            "opt": true,
            "type": "inte"
          },
          {
            "id": "level",
            "opt": true,
            "type": "number"
          },
          {
            "id": "race",
            "opt": true,
            "type": "number"
          },
          {
            "id": "attribute",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "player: number, code: number [, setcode: number, attack: number, defense: numbere, level: number, race: number, attribute: number]",
        "desc": "Creates a new Token with the passed in parameter value and returns",
        "id": "CreateToken",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "seq",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "targets: Card | Group, player: number | nil, seq: number, reason: number",
        "desc": "The reason for the targets sent to the players player card group, the return value is the actual number of operations\nIf player is nil, the card holder of the card is returned\nIf seq = 0, it is the top of the returned card group; seq = 1 is the bottom of the returned card group;\nThe rest of the case is to return to the top and mark the need to wash the card group.",
        "id": "SendtoDeck",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "targets",
            "type": "Card"
          }
        ],
        "argstr": "player: number, targets: Card | Group",
        "desc": "Identify targets for the player",
        "id": "ConfirmCards"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "sumtype",
            "opt": true,
            "type": "number"
          },
          {
            "id": "c",
            "opt": true,
            "type": "Card"
          }
        ],
        "argstr": "player: number [, sumtype: number, c: Card]",
        "desc": "Check player player can usually call [c, to sumtype]\nIf optional parameters are required, they must all be used\nReturns false only if the player receives an effect such as \"can not summon a superordinate\"",
        "id": "IsPlayerCanSummon",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "disable",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "[disable: boolean = true]",
        "desc": "So that the next operation does not check for the need for a wash card set or a hand card\nNote: If you do not call this function,\nIn addition to calling Duel.DiscardDeck and Duel.Draw remove the card from the card group or add the card to the card\nOr the card is added to the deck (not the top or bottom), the system automatically cleans the card group or the hand card at the end of the effect process\nIf you do not want to do so, for example, from the top of the card group, except for a card and other operations, you need to call this function\nThis function only ensures that no subsequent scrub detection is performed in the next operation",
        "id": "DisableShuffleCheck"
      },
      {
        "args": [],
        "desc": "In the call Duel.Damage / Duel.Recover, if is_step parameter is true, you need to call this function when the trigger point",
        "id": "RDComplete"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "cost",
            "type": "number"
          }
        ],
        "argstr": "player: number, cost: number",
        "desc": "Check player player can pay cost point lp",
        "id": "CheckLPCost",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "desc1",
            "type": "number"
          }
        ],
        "argstr": "player: number, desc1: number, ...",
        "desc": "Let the player select the option, starting with the second argument, where each parameter represents an option\nReturns the serial number of the selected option (0-based)",
        "id": "SelectOption",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "f: function, player: number, s: number, o: number, ex: Card | nil, ...",
        "desc": "Filter function to return to the specified location to meet the filter condition f and not equal to the first card ex.\nThe sixth parameter starts as an extra parameter.",
        "id": "GetFirstMatchingCard",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "counter_id",
            "type": "number"
          },
          {
            "id": "activity_type",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "counter_id: number, activity_type: number, f: function",
        "desc": "Set the action type to activity_type, code counter_id counter, placed in the initial_effect function\nF for the filter function, the card type parameters, the return value of false cards for the following types of operations, the counter increased by 1 (at present up to 1)\nThe activity_type is of the following type\nACTIVITY_SUMMON call (not including the usual call set)\nACTIVITY_NORMALSUMMON usually called (including the usual call set)\nACTIVITY_SPSUMMON Special call\nACTIVITY_FLIPSUMMON Reverse call\nACTIVITY_CHAIN ​​Activates the effect",
        "id": "AddCustomActivityCounter"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Returns the number of times a player fought this turn",
        "id": "GetBattledCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "",
        "id": "ReplaceAttacker"
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "targets: Card | Group, player: number | nil, reason: number",
        "desc": "The reason for the reason the spirit of the swing card targets sent to the player player extra card group, the return value is the actual number of operations\nIf player is nil, it returns the extra card group for the card holder.",
        "id": "SendtoExtraP",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "countertype",
            "type": "number"
          }
        ],
        "argstr": "player: number, s: number, o: number, countertype: number",
        "desc": "Returns the number of counterstype types that exist on the farm\nS represents the position of the player's own removable pointer, o represents the position of the opponent's removable pointer for the player.",
        "id": "GetCounter",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "number",
            "type": "number"
          }
        ],
        "argstr": "player: number, number: number, ...",
        "desc": "Let the player player declare a number\nStarting with the second argument, each parameter represents a declarable number\nThe first return value is the number of declarations, and the second return value is the declaration number of the position in all options",
        "id": "AnnounceNumber",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          }
        ],
        "argstr": "chainc: number, ...",
        "desc": "Returns the chainc information, if chainc = 0, returns the chain of information currently being processed\nThis function returns the corresponding number of return values ​​in sequence according to the number of arguments passed in. The arguments can be:\nCHAININFO_CHAIN_COUNT The serial number of the chain\nCHAININFO_TRIGGERING_EFFECT The effect of the chain\nCHAININFO_TRIGGERING_PLAYER\nCHAININFO_TRIGGERING_CONTROLER The player to which the chained position belongs\nCHAININFO_TRIGGERING_LOCATION The location where the chain occurred\nCHAININFO_TRIGGERING_SEQUENCE The number of the position where the chain occurred\nCHAININFO_TARGET_CARDS Chain of object cards\nCHAININFO_TARGET_PLAYER The target player for the chain\nCHAININFO_TARGET_PARAM The object parameters of the chain\nCHAININFO_DISABLE_REASON The chain is invalid for the effect of the effect\nCHAININFO_DISABLE_PLAYER The chain is invalid for the reason the player\nCHAININFO_CHAIN_ID The unique identifier for the chain\nCHAININFO_TYPE Type of Chain Card (Monster, Magic, Trap)\nCHAININFO_EXTTYPE The specific type of chain card (for example, monster, continuous magic, counterattack trap)\nFor example:\nDuel.GetChainInfo (0, CHAININFO_TRIGGERING_LOCATION, CHAININFO_TARGET_CARDS)\nThis will return the location and object card where the current chain occurred",
        "id": "GetChainInfo"
      },
      {
        "args": [
          {
            "id": "ec",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "re",
            "type": "Effect"
          },
          {
            "id": "r",
            "type": "number"
          },
          {
            "id": "rp",
            "type": "number"
          },
          {
            "id": "ep",
            "type": "number"
          },
          {
            "id": "ev",
            "type": "number"
          }
        ],
        "argstr": "ec: Card, code: number, re: Effect, r: number, rp: number, ep: number, ev: number",
        "desc": "To eg, ep, ev, re, r, rp for the card ec trigger a single point in time",
        "id": "RaiseSingleEvent"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "pos",
            "type": "number"
          }
        ],
        "argstr": "player: number, c: Card, pos: number",
        "desc": "Let player player select the Battle Position of c and return.",
        "id": "SelectPosition",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "value",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          },
          {
            "id": "is_step",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "player: number, value: number, reason: number [, is_step: boolean = false]",
        "desc": "To reason reason players to player value LP, return to the actual response value\nThe return value is 0 if it is affected by an effect such as a return to harm.\nIs_step to true is the damage / recovery LP process decomposition, need to call Duel.RDComplete () trigger point.",
        "id": "Recover",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "player: number, s: number, o: number, min: number, max: number, reason: number",
        "desc": "Let the player remove the min-max overlay card at the specified location for the reason reason. The return value indicates success",
        "id": "RemoveOverlayCard",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [],
        "desc": "Returns the current stage",
        "id": "GetCurrentPhase",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "player: number, code: number",
        "desc": "Manually reset the player player's specific logo effect",
        "id": "ResetFlagEffect"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "(Reserved)",
        "id": "ReplaceAttackTarget"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "tuner",
            "type": "Card"
          },
          {
            "id": "f1",
            "type": "function"
          },
          {
            "id": "f2",
            "type": "function"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "mg",
            "opt": true,
            "type": "Group"
          }
        ],
        "argstr": "c: Card, tuner: Card, f1: function, f2: function, min: number, max: number [, mg: Group]",
        "desc": "Check to tuner as an adjustment [in the mg] whether there is a set of min-max card to meet the conditions as cohort call c material\nF1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions",
        "id": "CheckTunerMaterial",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          }
        ],
        "argstr": "c1: Card, c2: Card",
        "desc": "Let c1 and c2 combat damage calculation",
        "id": "CalculateDamage"
      },
      {
        "args": [
          {
            "id": "c",
            "opt": true,
            "type": "Card"
          }
        ],
        "argstr": "[c: Card]",
        "desc": "Check whether the round player can still summon this turn [Card c]",
        "id": "CheckSummonedCount",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "f: function, player: number, s: number, o: number, ex: Card | nil, ...",
        "desc": "Filter function to return to the specified location to meet the filter condition f and not equal to the ex card.\nThe sixth parameter starts as an extra parameter.",
        "id": "GetMatchingGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number",
        "desc": "Returns the count card at the top of the player's deck",
        "id": "GetDecktopGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Returns the current LP of the player's player",
        "id": "GetLP",
        "ret": [
          "number"
        ]
      },
      {
        "args": [],
        "desc": "Returns all linked object cards that are normally only used when an object is used",
        "id": "GetFirstTarget",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [],
        "desc": "Invalid This attack, the return value indicates whether the success\nThis attack has been invalidated by other effects or cause the attack card can not attack is false",
        "id": "NegateAttack",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          }
        ],
        "argstr": "player: number, s: number, o: number",
        "desc": "Returns the number of cards in the specified location",
        "id": "GetFieldGroupCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "win_reason",
            "type": "number"
          }
        ],
        "argstr": "player: number, win_reason: number",
        "desc": "The current effect is dealt with so players win_reason duel victory",
        "id": "Win"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          }
        ],
        "argstr": "player: number, s: number, o: number",
        "desc": "Returns all stacked cards at a specified location",
        "id": "GetOverlayGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Returns the player's player's damage during this battle",
        "id": "GetBattleDamage",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Returns the deck of cards used for the normal summon c to be released (for higher-level summons)",
        "id": "GetTributeGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "e: Effect, c: Card",
        "desc": "",
        "id": "VenomSwampCheck",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [],
        "desc": "In the call Duel.Equip, if is_step parameter is true, you need to call this function when the trigger point",
        "id": "EquipComplete"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "location",
            "type": "number"
          },
          {
            "id": "use_player",
            "opt": true,
            "type": "number"
          },
          {
            "id": "reason",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "player: number, location: number [, use_player: number, reason: number = LOCATION_REASON_TOFIELD]",
        "desc": "Returns the number of spaces available in the player's field\nLocation can only be LOCATION_MZONE or LOCATION_SZONE\nReason is LOCATION_REASON_TOFIELD or LOCATION_REASON_CONTROL",
        "id": "GetLocationCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "player: number, c: Card",
        "desc": "Check whether the player can send c to hand",
        "id": "IsPlayerCanSendtoHand",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "countertype",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "player: number, countertype: number, count: number, c: Card",
        "desc": "Check if the player can add count counterstype to card c",
        "id": "IsCanAddCounter",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [],
        "desc": "Interrupt the current effect, so that after the effect of treatment as not treated simultaneously, this function will cause the wrong time",
        "id": "BreakEffect"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "lp",
            "type": "number"
          }
        ],
        "argstr": "player: number, lp: number",
        "desc": "Set the player's current LP to lp",
        "id": "SetLP"
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          },
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "chainc: number, g: Group",
        "desc": "The chain chainc the object into g",
        "id": "ChangeTargetCard"
      },
      {
        "args": [],
        "desc": "Refresh the card information on the field\nUnspecified or unclear principle Do not use this function to anil an infinite loop",
        "id": "Readjust"
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Liberation ceremony with the material g, if the ceremony is the cemetery and other magic cards are excluded",
        "id": "ReleaseRitualMaterial"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "mg",
            "opt": true,
            "type": "Group"
          },
          {
            "id": "ex",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "player: number, c: Card, min: number, max: number [, mg: Group, ex: boolean = false]",
        "desc": "Let the player player [from the mg] choose the min-max sacrifices that are normally used to summon c, ex = true to allow the monster on the other side of the field (the wing of the Sun God-Sphere).",
        "id": "SelectTribute",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [],
        "desc": "Returns the current round of players",
        "id": "GetTurnPlayer",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number, reason: number",
        "desc": "To reason player player card group top count cards sent to the cemetery, the actual transfer of the number.",
        "id": "DiscardDeck",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "countertype",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "player: number, s: number, o: number, countertype: number, count: number, reason: number",
        "desc": "Causes the player player to remove count objects of the countertype type present on the farm for reason reasons. The return value indicates success\nS represents the position of the player's own removable pointer, o represents the position of the opponent's removable pointer for the player",
        "id": "RemoveCounter",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "reason",
            "type": "number"
          },
          {
            "id": "dest",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "targets: Card | Group, reason: number [, dest: number = LOCATION_GRAVE]",
        "desc": "Destroy targets dest by reason reason, the return value is actually destroyed by the number\nIf the reason contains REASON_RULE, the break event will not check whether the card is immune,\nDoes not trigger the generation of breaking effect and ignore the \"can not destroy\"",
        "id": "Destroy",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "targets: Card | Group, player: number | nil, reason: number",
        "desc": "The reason to target the player sent to the player's hand, the return value is the actual number of operations",
        "id": "SendtoHand",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "available",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number, available: number",
        "desc": "Let the player player declare count races from the optional races\nAvailable is the combined value of all the optional races",
        "id": "AnnounceRace",
        "ret": [
          "number"
        ]
      },
      {
        "args": [],
        "argstr": "integer [, param]",
        "desc": "Sets the object parameters of the chain that is currently being processed into param",
        "id": "SetTargetParam"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "value",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          },
          {
            "id": "is_step",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "player: number, value: number, reason: number [, is_step: boolean = false]",
        "desc": "To the reason reason to give players the player caused value damage, the actual value of the damage received.\nThe return value is 0 if the damage becomes an effect such as a reply.\nIs_step to true is the damage / recovery LP process decomposition, need to call Duel.RDComplete () trigger point.",
        "id": "Damage",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "tuner",
            "type": "Card"
          },
          {
            "id": "mg",
            "opt": true,
            "type": "Group"
          }
        ],
        "argstr": "player: number, c: Card, tuner: Card [, mg: Group]",
        "desc": "Let the player player to tuner as the adjustment [mg for the material] on the c cohomology summon procedures",
        "id": "SynchroSummon"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "target_player",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "player: number, targets: Card | Group [, target_player: number = player]",
        "desc": "Let the player player place the targets into the target trap's magic trap\nIf targets is Group, the number of successful operations is returned",
        "id": "SSet",
        "ret": [
          "nil"
        ]
      },
      {
        "args": [],
        "desc": "The current processing of the chain of all the objects cleared",
        "id": "ClearTargetCard"
      },
      {
        "args": [],
        "desc": "Check the player at the current stage whether the operation (whether at the beginning of the stage, such as the Seven King of the sword)",
        "id": "CheckPhaseActivity",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [],
        "desc": "This function is called after determining that a number of calls to Duel.SpecialSummonStep are completed, for triggering an event",
        "id": "SpecialSummonComplete",
        "ret": [
          "nil"
        ]
      },
      {
        "args": [
          {
            "id": "event",
            "type": "number"
          },
          {
            "id": "get_info",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "event: number [, get_info: boolean]",
        "desc": "Check whether the current event point\nIf get_info = true and is the correct time point also returns the trigger point information eg, ep, ev, re, r, rp",
        "id": "CheckEvent",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "player: number, f: function, min: number, max: number, ex: Card | nil, ...",
        "desc": "Filter function, allowing the player player from the field · hand card selection min-max Zhang does not equal ex to meet the conditions of f can be liberated card (non-superior call)",
        "id": "SelectReleaseGroupEx",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [],
        "desc": "Returns the two values ​​that represent the current venue code, as well as the source of the current venue effect\nThe site code refers to the code of the venue card in effect, or the value of the effect of the venue change\nSource Player is the controller of the card in effect, or the controller of the Poseidon Witch, etc.",
        "id": "GetEnvironment",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "value",
            "type": "number"
          },
          {
            "id": "check",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "player: number, value: number [, check: boolean = true]",
        "desc": "The player player in this battle by the harm into value, check for false is the original combat damage to 0 also change the damage",
        "id": "ChangeBattleDamage"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card | nil",
        "desc": "Will attack the object into c, c for nil that direct attack, the return value indicates whether the successful transfer of attack objects",
        "id": "ChangeAttackTarget",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [],
        "desc": "This function returns a card set that was actually manipulated before a card operation\nDuel. Destroy, Duel.Remove, Duel.SendtoGrave,\nDuel.SendtoHand, Duel.SendtoDeck, Duel.SendtoExtraP, Duel.Release,\nDuel.ChangePosition, Duel.SpecialSummon, Duel.DiscardDeck",
        "id": "GetOperatedGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [],
        "desc": "Check whether the player can enter the combat phase of the round",
        "id": "IsAbleToEnterBP",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "counter_id",
            "type": "number"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "activity_type",
            "type": "number"
          }
        ],
        "argstr": "counter_id: number, player: number, activity_type: number",
        "desc": "Counter number counter_id count, the number of players to return to the following (currently up to 1)\nThe activity_type is of the following type\nACTIVITY_SUMMON call (not including the usual call set)\nACTIVITY_NORMALSUMMON usually called (including the usual call set)\nACTIVITY_SPSUMMON Special call\nACTIVITY_FLIPSUMMON Reverse call\nACTIVITY_CHAIN ​​Activates the effect",
        "id": "GetCustomActivityCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Set g to be the fusion material you want to use",
        "id": "SetFusionMaterial"
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "chainc: number, c: Card",
        "desc": "Check whether c is the correct object for chained chainc effects",
        "id": "CheckChainTarget",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "player: number, c: Card",
        "desc": "Check whether the player can reverse the call player c",
        "id": "IsPlayerCanFlipSummon",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          }
        ],
        "argstr": "chainc: number",
        "desc": "Returns the number of operational classifications contained in chained chainc",
        "id": "GetOperationCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "seq",
            "type": "number"
          }
        ],
        "argstr": "c: Card, seq: number",
        "desc": "Move the serial number of c, usually used to change the grid in the field or in the card group to move to the top or bottom",
        "id": "MoveSequence"
      },
      {
        "args": [
          {
            "id": "cards",
            "type": "Card"
          }
        ],
        "argstr": "cards: Card | Group",
        "desc": "Set the card to the selected card for Group.SelectWithSumEqual or Group.SelectWithSumGreater,",
        "id": "SetSelectedCard"
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "targets: Card | Group, reason: number",
        "desc": "The reason for the liberation of targets to return the value of the actual liberation of the number of targets\nIf the reason contains REASON_COST, it will not check whether the card is not affected by the effect",
        "id": "Release",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "player: number, c: Card",
        "desc": "Check whether the player can send c to the card group",
        "id": "IsPlayerCanSendtoDeck",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "player: number, c: Card",
        "desc": "Check whether the player can send c to the cemetery",
        "id": "IsPlayerCanSendtoGrave",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "reset_flag",
            "type": "number"
          },
          {
            "id": "property",
            "type": "number"
          },
          {
            "id": "reset_count",
            "type": "number"
          }
        ],
        "argstr": "player: number, code: number, reset_flag: number, property: number, reset_count: number",
        "desc": "For the player to register the global environment logo effect\nThis effect always affects the player's (EFFECT_FLAG_PLAYER_TARGET) and will not be invalidated\nThe rest is the same as Card.RegisterFlagEffect",
        "id": "RegisterFlagEffect",
        "ret": [
          "Effect"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "player: number, c: Card",
        "desc": "Check whether the player player except c",
        "id": "IsPlayerCanRemove",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "f: function, player: number, s: number, o: number, ex: Card | nil, ...",
        "desc": "Filter function to return to the specified location to meet the filter condition f and not equal to the number of ex card.",
        "id": "GetMatchingGroupCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          }
        ],
        "argstr": "targets: Card | Group",
        "desc": "So that the call is being summoned · reverse call special summoned targets invalid",
        "id": "NegateSummon"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "player: number, f: function, count: number, ex: Card | nil, ...",
        "desc": "Check whether there are at least count cards that can satisfy the filter condition f and are not equal to ex. (For non-superior summoning)",
        "id": "CheckReleaseGroupEx",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "player: number, c: Card",
        "desc": "Check whether the player can liberate the player c",
        "id": "IsPlayerCanRelease",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "reset",
            "type": "number"
          }
        ],
        "argstr": "c: Card, reset: number",
        "desc": "So that card c has launched the chain are invalid, reset event occurs reset",
        "id": "NegateRelatedChain"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "pos",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c: Card [, pos: number]",
        "desc": "To return the form c to the field pos, pos default value is the expression before leaving the field, the return value indicates whether the success\nC must be a REASON_TEMPORARY reason to leave, and leave the position did not leave that position",
        "id": "ReturnToField",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number",
        "desc": "Check player player can put the card group top count cards sent to the cemetery",
        "id": "IsPlayerCanDiscardDeck",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number",
        "desc": "Check whether the player player special call count times",
        "id": "IsPlayerCanSpecialSummonCount",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "setcode",
            "type": "number"
          },
          {
            "id": "type",
            "type": "number"
          },
          {
            "id": "atk",
            "type": "number"
          },
          {
            "id": "def",
            "type": "number"
          },
          {
            "id": "level",
            "type": "number"
          },
          {
            "id": "race",
            "type": "number"
          },
          {
            "id": "attribute",
            "type": "number"
          },
          {
            "id": "pos",
            "opt": true,
            "type": "Integer"
          },
          {
            "id": "target_player",
            "opt": true,
            "type": "integer"
          },
          {
            "id": "sumtype",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "player: number, code: number, setcode: number, type: number, atk: number, def: number, level: number, race: number, attribute: number [, pos: Integer = POS_FACEUP, target_player: numbereger = player, sumtype: number]",
        "desc": "Check player player can be pos to the form of special summon the parameters of the monster to the target_player field\nThis function is usually used to determine whether it is possible to trick token and trap monsters",
        "id": "IsPlayerCanSpecialSummonMonster",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "targets: Card | Group, reason: number",
        "desc": "The reason for the targets to the cemetery, the return value is the actual number of operations",
        "id": "SendtoGrave",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          }
        ],
        "argstr": "chainc: number",
        "desc": "Check chainC effect can be invalid",
        "id": "IsChainDisablable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "countertype",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "player: number, s: number, o: number, countertype: number, count: number, reason: number",
        "desc": "Checks whether the player player can remove count objects of the countertype type on the farm for reason reasons\nS represents the position of the player's own removable pointer, o represents the position of the opponent's removable pointer for the player.",
        "id": "IsCanRemoveCounter",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "sumtype",
            "opt": true,
            "type": "number"
          },
          {
            "id": "sumpos",
            "opt": true,
            "type": "number"
          },
          {
            "id": "target_player",
            "opt": true,
            "type": "number"
          },
          {
            "id": "c",
            "opt": true,
            "type": "Card"
          }
        ],
        "argstr": "player: number [, sumtype: number, sumpos: number, target_player: number, c: Card]",
        "desc": "Check player player can special summon [c to target_player field to sumtype summation, sumpos form]\nIf optional parameters are required, they must all be used",
        "id": "IsPlayerCanSpecialSummon",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number",
        "desc": "Check the player player can put the card group top count cards sent to the cemetery as cost",
        "id": "IsPlayerCanDiscardDeckAsCost",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "player: number [, count: number = 0]",
        "desc": "Check the player player can effect pumping [count Zhang] card",
        "id": "IsPlayerCanDraw",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "player: number, code: number",
        "desc": "Check if the player is affected by the effect of the code type, and return the effect if there is one",
        "id": "IsPlayerAffectedByEffect",
        "ret": [
          "Effect"
        ]
      },
      {
        "args": [
          {
            "id": "res",
            "type": "number"
          }
        ],
        "argstr": "res: number, ...",
        "desc": "Forcibly modify the result of casting dice to res\nThis function is used in the persistent EVENT_TOSS_DICE event",
        "id": "SetDiceResult"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Will attack the monster into c\nNote: This function will make the original attack monster attack",
        "id": "ChangeAttacker"
      },
      {
        "args": [],
        "desc": "Returns the result of the current dice",
        "id": "GetDiceResult",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "use_hand",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "player: number [, use_hand: boolean = false]",
        "desc": "Return player player can be liberated (non-superior summoned with) the number of cards, use_hand is true, including the hand card",
        "id": "GetReleaseGroupCount",
        "ret": [
          "integer"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Returns the player's number of rules drawn per turn",
        "id": "GetDrawCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Manual wash player player's hand card\nNOTE: The status of the wash detection is reset",
        "id": "ShuffleHand"
      },
      {
        "args": [],
        "desc": "Returns the result of the current coin",
        "id": "GetCoinResult",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count1",
            "type": "number"
          },
          {
            "id": "count2",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "player: number, count1: number [, count2: number = 0]",
        "desc": "Let the player to cast count1 dice [, 1-player to vote count2 dice] (count1 + count2 <= 5)\nThe return value is count1 + count2 results, 1-6",
        "id": "TossDice"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number",
        "desc": "Let the player player cast count (<= 5) coins, the return value for the count results, 0 or 1.",
        "id": "TossCoin"
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "f: function, player: number, s: number, o: number, count: number, ex: Card | nil, ...",
        "desc": "Filter the function to check if there are at least count cards that satisfy the filter condition f and not equal to ex\nThe seventh argument starts as an extra parameter",
        "id": "IsExistingMatchingCard",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number [, type = TYPE_MONSTER + TYPE_SPELL + TYPE_TRAP]",
        "desc": "Let players declare a player [type type] card code",
        "id": "AnnounceCard",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Let the player declare a level",
        "id": "AnnounceLevel",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "opt": true,
            "type": "Card"
          }
        ],
        "argstr": "[c: Card]",
        "desc": "Manual consumption of 1 player [for card c] the number of the usual call",
        "id": "IncreaseSummonedCount"
      },
      {
        "args": [],
        "desc": "Returns the current number of turns",
        "id": "GetTurnCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "sumtype",
            "type": "number"
          },
          {
            "id": "sumplayer",
            "type": "number"
          },
          {
            "id": "target_player",
            "type": "number"
          },
          {
            "id": "nocheck",
            "type": "boolean"
          },
          {
            "id": "nolimit",
            "type": "boolean"
          },
          {
            "id": "pos",
            "type": "number"
          }
        ],
        "argstr": "targets: Card | Group, sumtype: number, sumplayer: number, target_player: number, nocheck: boolean, nolimit: boolean, pos: number",
        "desc": "Let player player to sumtype way, pos that special targets to target_player target field\nIf nocheck is true, the card's calling condition is disregarded. If nolimit is true,\nThe return value is the number of cards that were successfully summoned.",
        "id": "SpecialSummon",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Let the player player declare a card type",
        "id": "AnnounceType",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "f: function",
        "desc": "Set the chain conditions, f function prototype for boolean f (e, ep, tp)\nE said to limit the effect of chain, ep said to limit the chain of players, tp that launched the effect of the players\nCalling this function in cost or target processing can limit the kinds of effects that can be chained (such as superfusion)\nIf f returns false, it means that the chain can not be chained. Once the chain condition has been set, the new chain will be canceled.",
        "id": "SetChainLimit"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Let the player declare the positive and negative sides of the coin",
        "id": "AnnounceCoin",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          }
        ],
        "argstr": "chainc: number",
        "desc": "So that the chain chainc invalid effect, the return value that is successful",
        "id": "NegateEffect",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "au",
            "type": "number"
          },
          {
            "id": "ad",
            "opt": true,
            "type": "number"
          },
          {
            "id": "du",
            "opt": true,
            "type": "number"
          },
          {
            "id": "dd",
            "opt": true,
            "type": "number"
          },
          {
            "id": "noflip",
            "opt": true,
            "type": "boolean"
          },
          {
            "id": "setavailable",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "targets: Card | Group, au: number [, ad: number = au, du: number = au, dd: number = au, noflip: boolean = false, setavailable: boolean = false]",
        "desc": "Changes the Battle Position of targets returns the number of actual operations\nThe attack on the watch side becomes au, the attack on the inside indicates ad,\nThe side of the garage that becomes du, inside the garrison said to become dd\nIf noflip = true, the reverse effect will not be triggered (but the effect of inversion will be triggered)\nIf setavailable = true then the object will become the back side also launched reversal effect",
        "id": "ChangePosition",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "available",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number, available: number",
        "desc": "Let the player player declare count attributes from the optional attribute\nAvailable is the combined value of all optional attributes",
        "id": "AnnounceAttribute",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "opt": true,
            "type": "Card"
          }
        ],
        "argstr": "[c: Card]",
        "desc": "So that the attack card [or card c] can be carried out an attack (opening up, the queen of the Queen)",
        "id": "ChainAttack"
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "pos",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "targets: Card | Group, pos: number, reason: number",
        "desc": "In the case of reason, except for the pos form, the return value is the actual number being manipulated\nIf the reason contains REASON_TEMPORARY, then the exception is considered temporary, you can return to the field by Duel.ReturnToField",
        "id": "Remove",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "filter",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number, s: number, o: number, filter: number",
        "desc": "Let the player player select the specified position to meet the marker condition filter count of the available space, and return to select the location of the marker\nCommonly used to select areas can not use or move the monster grid",
        "id": "SelectDisableField",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "mg",
            "opt": true,
            "type": "Group"
          },
          {
            "id": "ex",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "c: Card [, mg: Group, ex: boolean = false]",
        "desc": "Returns the number of sacrifices that are normally used to invoke c, where ex = true allows monsters on the other side of the field (the wing of the Sun God-Sphere)\nThis number does not necessarily equal the number of cards in the return value of Duel.GetTributeGroup\nBecause some cards can be used as two sacrifices",
        "id": "GetTributeCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [],
        "desc": "",
        "id": "SelectSequence"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "player: number, c: Card",
        "desc": "Let players choose whether to launch the card player c effect",
        "id": "SelectEffectYesNo",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Manually displays the animated effect of the selected object for g and records that the card is selected as the object",
        "id": "HintSelection"
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "reset_phase",
            "opt": true,
            "type": "number"
          },
          {
            "id": "reset_count",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "targets: Card | Group, player: number [, reset_phase: number = 0, reset_count: number = 0]",
        "desc": "Let players get control of the player, the return value indicates success",
        "id": "GetControl",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          }
        ],
        "argstr": "player: number, s: number, o: number",
        "desc": "Returns the number of all stacked cards in the specified location.",
        "id": "GetOverlayCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "ignore_count",
            "type": "boolean"
          },
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "player: number, c: Card, ignore_count: boolean, e: Effect | nil [, min = 0]",
        "desc": "Let the player to the effect of e to c is usually called (not set), at least use min sacrifice\nIf e = nil, then in accordance with the general rules of the general call usually call\nIf ignore_count = true, the usual number of calls per turn limit is ignored",
        "id": "Summon"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "location",
            "type": "number"
          },
          {
            "id": "seq",
            "type": "number"
          }
        ],
        "argstr": "player: number, location: number, seq: number",
        "desc": "Check if the player's player field is seq in the location of the space is available",
        "id": "CheckLocation",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "ocard",
            "type": "Card"
          }
        ],
        "argstr": "c: Card, ocard: Card | Group",
        "desc": "The ocard as a stack of cards stacked c",
        "id": "Overlay"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "lv",
            "type": "number"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "mg",
            "type": "Group"
          }
        ],
        "argstr": "c: Card, f: function, lv: number, min: number, max: number, mg: Group | nil",
        "desc": "Check on the field or mg in the presence of excess call c excess with the level of lv min-max meet the conditions of the stack f material",
        "id": "CheckXyzMaterial",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number",
        "desc": "Confirm the player card group above count cards",
        "id": "ConfirmDecktop"
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          },
          {
            "id": "category",
            "type": "number"
          },
          {
            "id": "targets",
            "type": "Card"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "target_player",
            "type": "number"
          },
          {
            "id": "target_param",
            "type": "number"
          }
        ],
        "argstr": "chainc: number, category: number, targets: Card | Group, count: number, target_player: number, target_param: number",
        "desc": "Sets the operation information of the currently processed chain This operation information contains the effect classification determined in the effect processing to be processed\nFor example, stealth snipers need to set CATEGORY_DICE, but can not set CATEGORY_DESTROY, because not sure\nFor destructive effects, targets need to be set to launch the object may become the impact of chain card,\nAnd sets count to the number of cards to be processed as determined at launch\nFor example, when the black hole launched, targets need to be set to all the monsters on the field, count to set the number of strange field\nFor CATEGORY_SPECIAL_SUMMON, CATEGORY_TOHAND, CATEGORY_TODECK, etc., which need to move the card position,\nIf the card to be processed is deterministic (such as fetching objects), set targets for these cards, count for the number,\nIf the card to be processed is uncertain (the effect can be determined when processing, is generally not take the effect of the object)\nSet the targets to nil, count is expected to deal with the number of cards,\nTarget_player is expected to be handled by the holder of the card (not sure to 0)\nTarget_param is the location of the card expected to be processed\nFor example: SetOperationInfo (0, CATEGORY_TOHAND, nil, 1, tp, LOCATION_DECK)\nOperational information is used to initiate detection of many effects, such as Stardust Dragon, Royal Valley",
        "id": "SetOperationInfo"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Set the player that is currently handling the chained object to player",
        "id": "SetTargetPlayer"
      },
      {
        "args": [
          {
            "id": "targets",
            "type": "Card"
          }
        ],
        "argstr": "targets: Card | Group",
        "desc": "Sets the currently chained objects to targets\nNote that here the object refers to the generalized object, including objects that do not take the effect that the object may have to deal with",
        "id": "SetTargetCard"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "player: number, count: number, reason: number",
        "desc": "Let the player play the count card with the reason, and return the number of cards actually drawn\nIf the reason contains REASON_RULE the draw is not affected by the \"can not draw\" effect",
        "id": "Draw",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          }
        ],
        "argstr": "chainc: number",
        "desc": "Check the chain chainc launch can be invalid",
        "id": "IsChainNegatable",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          },
          {
            "id": "reset_phase",
            "opt": true,
            "type": "number"
          },
          {
            "id": "reset_count",
            "opt": true,
            "type": "number"
          }
        ],
        "argstr": "c1: Card, c2: Card [, reset_phase: number = 0, reset_count: number = 0]",
        "desc": "Exchange c1 and c2 control, the return value that is successful",
        "id": "SwapControl",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "tuner",
            "type": "Card"
          },
          {
            "id": "f1",
            "type": "function"
          },
          {
            "id": "f2",
            "type": "function"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "mg",
            "opt": true,
            "type": "Group"
          }
        ],
        "argstr": "player: number, c: Card, tuner: Card, f1: function, f2: function, min: number, max: number [, mg: Group]",
        "desc": "Let the player [from the mg] select a set of clips of the min-max cards that are tuned to be used for co-ordination of the required conditions for c.\nF1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions",
        "id": "SelectTunerMaterial",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "f1",
            "type": "function"
          },
          {
            "id": "f2",
            "type": "function"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "smat",
            "opt": true,
            "type": "Card"
          },
          {
            "id": "mg",
            "opt": true,
            "type": "Group"
          }
        ],
        "argstr": "player: number, c: Card, f1: function, f2: function, min: number, max: number [, smat: Card, mg: Group]",
        "desc": "Let the player player [from mg] select a set of clips that are required for the cohomology c [must contain smat (if there is mg ~ = nil this parameter is ignored)] The number of min-max clips that satisfy the condition\nF1 is to adjust the filter conditions to be met, f2 is outside the adjustment to meet the needs of the filter conditions",
        "id": "SelectSynchroMaterial",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "f: function, player: number, s: number, o: number, ex: Card | nil, ...",
        "desc": "Basic with Duel.GetMatchingGroupCount, the difference lies in the need to add to determine whether the card is currently being processed by the effect of the object.",
        "id": "GetTargetCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "activity_type",
            "type": "number"
          }
        ],
        "argstr": "player: number, activity_type: number, ...",
        "desc": "Returns the number of times the player performed the corresponding activity_type operation\nThe activity_type is of the following type\nACTIVITY_SUMMON call (not including the usual call placed)\nACTIVITY_NORMALSUMMON Usually called (including the usual call placed)\nACTIVITY_SPSUMMON Special call\nACTIVITY_FLIPSUMMON Reverse call\nACTIVITY_ATTACK attack\nACTIVITY_BATTLE_PHASE enters the combat phase",
        "id": "GetActivityCount",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "g",
            "type": "Group"
          }
        ],
        "argstr": "g: Group",
        "desc": "Set g to be the cohomology material you want to use",
        "id": "SetSynchroMaterial"
      },
      {
        "args": [
          {
            "id": "timing",
            "type": "number"
          }
        ],
        "argstr": "timing: number",
        "desc": "Check whether the current prompt is the timing point",
        "id": "CheckTiming",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "player: number, f: function, count: number, ex: Card | nil, ...",
        "desc": "Check if the player has at least count of cards that meet the filter condition f and are not equal to ex (non-superior summons)\nThe fifth parameter starts as an extra parameter",
        "id": "CheckReleaseGroup",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          },
          {
            "id": "player",
            "type": "in"
          }
        ],
        "argstr": "chainc: number, player: in",
        "desc": "The chain chainc the object player into player",
        "id": "ChangeTargetPlayer"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "use_hand",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "player: number [, use_hand: boolean = false]",
        "desc": "Return to the player player can be liberated (non-superior summoned use) of the deck, use_hand is true, including the hand card",
        "id": "GetReleaseGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "sel_player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "sel_player: number, f: function, player: number, s: number, o: number, min: number, max: number, ex: Card | nil, ...",
        "desc": "Filter function, the player sel_player select the specified location to meet the filter condition f and not equal to the ex min-max card\nThe ninth parameter starts as an extra parameter",
        "id": "SelectMatchingCard",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "code",
            "type": "number"
          }
        ],
        "argstr": "player: number, code: number",
        "desc": "Returns the number of specific marker effects for the player's player",
        "id": "GetFlagEffect",
        "ret": [
          "number"
        ]
      },
      {
        "args": [],
        "desc": "Returns the chain number currently being processed",
        "id": "GetCurrentChain",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "player: number, c: Card",
        "desc": "Let player player on c special summon procedures",
        "id": "SpecialSummonRule"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          }
        ],
        "argstr": "player: number, s: number, o: number",
        "desc": "Returns the card at the specified location",
        "id": "GetFieldGroup",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "eg",
            "type": "Group"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "re",
            "type": "Effect"
          },
          {
            "id": "r",
            "type": "number"
          },
          {
            "id": "rp",
            "type": "number"
          },
          {
            "id": "ep",
            "type": "number"
          },
          {
            "id": "ev",
            "type": "number"
          }
        ],
        "argstr": "eg: Group | Card, code: number, re: Effect, r: number, rp: number, ep: number, ev: number",
        "desc": "To eg, ep, ev, re, r, rp trigger a point in time",
        "id": "RaiseEvent"
      },
      {
        "args": [],
        "desc": "Return to the battle was attacked card, if the return nil said that a direct attack",
        "id": "GetAttackTarget",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [],
        "desc": "Return the card for this combat attack",
        "id": "GetAttacker",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "location",
            "type": "number"
          },
          {
            "id": "seq",
            "type": "number"
          }
        ],
        "argstr": "player: number, location: number, seq: number",
        "desc": "Back to player The player's field is located in the location number seq card, commonly used to obtain the field area · Spirit pendulum area card",
        "id": "GetFieldCard",
        "ret": [
          "Card"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "sumtype",
            "type": "number"
          },
          {
            "id": "sumplayer",
            "type": "number"
          },
          {
            "id": "target_player",
            "type": "number"
          },
          {
            "id": "nocheck",
            "type": "boolean"
          },
          {
            "id": "nolimit",
            "type": "boolean"
          },
          {
            "id": "pos",
            "type": "number"
          }
        ],
        "argstr": "c: Card, sumtype: number, sumplayer: number, target_player: number, nocheck: boolean, nolimit: boolean, pos: number",
        "desc": "This function is Duel.SpecialSummon decomposition process, only a special summon a card c\nThis function is used for an effect while simultaneously calling multiple cards with different parameters\nThis function must be used with Duel.SpecialSummonComplete\nThe return value indicates whether or not the special call succeeded",
        "id": "SpecialSummonStep",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          },
          {
            "id": "param",
            "type": "number"
          }
        ],
        "argstr": "chainc: number, param: number",
        "desc": "The chain chainc parameters into param",
        "id": "ChangeTargetParam"
      },
      {
        "args": [
          {
            "id": "res",
            "type": "number"
          }
        ],
        "argstr": "res: number, ...",
        "desc": "Forcibly modify the result of casting coins to res\nThis function is used in the persistent EVENT_TOSS_COIN event",
        "id": "SetCoinResult"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Manually cleans the player group\nNOTE: The status of the wash detection is reset",
        "id": "ShuffleDeck"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Returns the player's deck of cards available for ritual summoning material\nIncluding hands, the field can be the liberation of the ceremony and the cemetery and other magic people card",
        "id": "GetRitualMaterial",
        "ret": [
          "Group"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "cost",
            "type": "number"
          }
        ],
        "argstr": "player: number, cost: number",
        "desc": "Allow players to pay cost point player lp",
        "id": "PayLPCost"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "min",
            "type": "number"
          },
          {
            "id": "max",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          },
          {
            "id": "ex",
            "type": "Card"
          }
        ],
        "argstr": "player: number, f: function, min: number, max: number, reason: number, ex: Card | nil, ...",
        "desc": "Filter function allows the player to select and discard the player to meet the screening conditions f soldiers is not equal to ex min-max Zhang card.\nThe seventh argument starts as an extra parameter.",
        "id": "DiscardHand",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "Returns the effect of the chained material that is played by the player. This function is only used to blend the effect of a class card",
        "id": "GetChainMaterial",
        "ret": [
          "Effect"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "s",
            "type": "number"
          },
          {
            "id": "o",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          },
          {
            "id": "reason",
            "type": "number"
          }
        ],
        "argstr": "player: number, s: number, o: number, count: number, reason: number",
        "desc": "Check if the player can remove at least count cards for the specified reason",
        "id": "CheckRemoveOverlayCard",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "ignore_count",
            "type": "boolean"
          },
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "player: number, c: Card, ignore_count: boolean, e: Effect | nil [, min = 0]",
        "desc": "Let the player to the effect of c is usually called Set, at least use min sacrifice\nIf e = nil, then in accordance with the general rules of the general call usually call\nIf ignore_count = true, the usual number of calls per turn limit is ignored",
        "id": "MSet"
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          },
          {
            "id": "c1",
            "type": "Card"
          },
          {
            "id": "c2",
            "type": "Card"
          },
          {
            "id": "up",
            "opt": true,
            "type": "boolean"
          },
          {
            "id": "is_step",
            "opt": true,
            "type": "boolean"
          }
        ],
        "argstr": "player: number, c1: Card, c2: Card [, up: boolean = true, is_step: boolean = false]",
        "desc": "The player as a player c1 equipment card equipment to the c2, the return value that is successful\nUp = false to retain the card before the representation\nIs_step = true is the decomposition of the equipment process, the need to cooperate with Duel.EquipComplete use",
        "id": "Equip",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "move_player",
            "type": "number"
          },
          {
            "id": "target_player",
            "type": "number"
          },
          {
            "id": "dest",
            "type": "number"
          },
          {
            "id": "pos",
            "type": "number"
          },
          {
            "id": "enabled",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, move_player: number, target_player: number, dest: number, pos: number, enabled: boolean",
        "desc": "Let the player move_player to move the c target_player field, the return value that is successful\nDest can only be LOCATION_MZONE or LOCATION_SZONE, pos represents an optional Battle Position, and enable indicates whether or not the effect of c is applied immediately",
        "id": "MoveToField",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "player: number",
        "desc": "This world and the underworld reversal dedicated. The players player card group and the cemetery exchange",
        "id": "SwapDeckAndGrave"
      },
      {
        "args": [
          {
            "id": "sort_player",
            "type": "number"
          },
          {
            "id": "target_player",
            "type": "number"
          },
          {
            "id": "count",
            "type": "number"
          }
        ],
        "argstr": "sort_player: number, target_player: number, count: number",
        "desc": "Let the player sort_player on the player target_player card group at the top count card sort",
        "id": "SortDecktop"
      },
      {
        "args": [
          {
            "id": "chainc",
            "type": "number"
          }
        ],
        "argstr": "chainc: number",
        "desc": "So that the chain chainc launch invalid, the return value that is successful",
        "id": "NegateActivation",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          },
          {
            "id": "player",
            "type": "number"
          }
        ],
        "argstr": "e: Effect, player: number",
        "desc": "Register the effect e as the player's effect to the global environment",
        "id": "RegisterEffect"
      }
    ]
  },
  {
    "cls": "aux",
    "methods": [
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "f: function, value, a, b, c",
        "desc": "Return function (effect, target)\nReturn f (target, a, b, c) == value\nEnd",
        "id": "TargetEqualFunction",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "lv",
            "type": "number"
          },
          {
            "id": "ct",
            "type": "number"
          },
          {
            "id": "alterf",
            "opt": true,
            "type": "function"
          },
          {
            "id": "maxct",
            "opt": true,
            "type": "number"
          },
          {
            "id": "op",
            "opt": true,
            "type": "function"
          }
        ],
        "argstr": "c: Card, f: function, lv: number, ct: number [, alterf: function | nil, maxct: number = ct, op: function | nil]",
        "desc": "Add an excess summon for c\nWith the conditions to meet the conditions for the f-level cv-maxct lv monster to be stacked\nThe rest of the parameters are used to stack on a single monster (usually an excess of monsters)\nAlterf for this monster to meet the conditions, desc for the description, op for the stacked operation (hope Huanglong)",
        "id": "AddXyzProcedure"
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "f: function, value, a, b, c",
        "desc": "Return function (target)\nReturn f (target, a, b, c) == value\nEnd",
        "id": "FilterEqualFunction",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "f1",
            "type": "function"
          },
          {
            "id": "f2",
            "type": "function"
          },
          {
            "id": "ct",
            "type": "number"
          }
        ],
        "argstr": "c: Card, f1: function, f2: function, ct: number",
        "desc": "Add a cohomology call to c\nF1 to adjust the filter to meet the conditions, f2 to adjust to meet other than the filter conditions (usually aux.NonTuner)\nAdjust monsters other than ct at least",
        "id": "AddSynchroProcedure"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "f1",
            "type": "function"
          },
          {
            "id": "f2",
            "type": "function"
          },
          {
            "id": "insf",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, f1: function, f2: function, insf: boolean",
        "desc": "For the c to specify conditions for the f1 and f2 monsters for the fusion material",
        "id": "AddFusionProcFun2"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card",
        "desc": "Add Gemini for the c monster attributes",
        "id": "EnableDualAttribute"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code1",
            "type": "number"
          },
          {
            "id": "code2",
            "type": "number"
          },
          {
            "id": "code3",
            "type": "number"
          },
          {
            "id": "code4",
            "type": "number"
          },
          {
            "id": "sub",
            "type": "boolean"
          },
          {
            "id": "insf",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, code1: number, code2: number, code3: number, code4: number, sub: boolean, insf: boolean",
        "desc": "For the c designated card number for the code1, code2, code3, code4 monster for the fusion material",
        "id": "AddFusionProcCode4"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "cc",
            "type": "number"
          },
          {
            "id": "sub",
            "type": "boolean"
          },
          {
            "id": "insf",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, code: number, cc: number, sub: boolean, insf: boolean",
        "desc": "For the c designated cc the same monster for the fusion material, code for the card number",
        "id": "AddFusionProcCodeRep"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Check if the Gemini monster e: GetHandler () is considered a normal monster state",
        "id": "DualNormalCondition",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [],
        "desc": "Start the mess",
        "id": "BeginPuzzle"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code1",
            "type": "number"
          },
          {
            "id": "code2",
            "type": "number"
          },
          {
            "id": "sub",
            "type": "boolean"
          },
          {
            "id": "insf",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, code1: number, code2: number, sub: boolean, insf: boolean",
        "desc": "For the c designated card number for the code1 and code2 monster for the fusion material\nSub that can use fusion instead of material, insf that can be summoned with a simple fusion",
        "id": "AddFusionProcCode2"
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Antisense of aux.IsDualState",
        "id": "IsNotDualState",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "e",
            "type": "Effect"
          }
        ],
        "argstr": "e: Effect",
        "desc": "Check the Gemini monster e: GetHandler () is re-call state\nCommonly used in the Gemini monster re-summoned to obtain the effect of e Condition attribute",
        "id": "IsDualState",
        "ret": [
          "boolean"
        ]
      },
      {
        "args": [
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "id",
            "type": "number"
          }
        ],
        "argstr": "code: number, id: number",
        "desc": "Used to index the card number code for the card the first id (from 0) effect prompts",
        "id": "Stringid",
        "ret": [
          "number"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          }
        ],
        "argstr": "c: Card [, active_effect = true]",
        "desc": "For the spirit to put the monster c to add the soul to put the monster attributes (spiritual swing call, the spirit of the launch of the card)\nActive_effect = false is not registered Ling card \"card launch\" effect",
        "id": "EnablePendulumAttribute"
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "f: function, a, b, c",
        "desc": "Return function (effect, target)\nReturn f (target, a, b, c)\nEnd",
        "id": "TargetBoolFunction",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "f1",
            "type": "function"
          },
          {
            "id": "f2",
            "type": "function"
          }
        ],
        "argstr": "c: Card, f1: function, f2: function",
        "desc": "Add a cohomology call to c\nF1 to adjust the filter to meet the conditions, f2 to adjust to meet other than the filter conditions (usually aux.NonTuner)\nCan only be adjusted with a monster outside",
        "id": "AddSynchroProcedure2"
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "f: function, a, b, c",
        "desc": "Return function (target)\nReturn target: IsNotTuner () and (not f or f (target, a, b, c))\nEnd",
        "id": "NonTuner",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code",
            "type": "number"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "cc",
            "type": "number"
          },
          {
            "id": "sub",
            "type": "boolean"
          },
          {
            "id": "insf",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, code: number, f: function, cc: number, sub: boolean, insf: boolean",
        "desc": "For the c designated card number for the code and cc meet the conditions of the monster f fusion material",
        "id": "AddFusionProcCodeFun"
      },
      {
        "args": [
          {
            "id": "f",
            "type": "function"
          }
        ],
        "argstr": "f: function, a, b, c",
        "desc": "Return function (target)\nReturn f (target, a, b, c)\nEnd",
        "id": "FilterBoolFunction",
        "ret": [
          "function"
        ]
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "filter",
            "type": "function"
          }
        ],
        "argstr": "c: Card, filter: function",
        "desc": "Add a ritual summon effect to c\nFilter for the ritual monster to meet the conditions, the material level can be more than the ritual monster level",
        "id": "AddRitualProcGreater"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "filter",
            "type": "function"
          }
        ],
        "argstr": "c: Card, filter: function",
        "desc": "Add a ritual summon effect to c\nFilter for the ritual monster to meet the conditions, the material level must be equal to the ritual monster level",
        "id": "AddRitualProcEqual"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "code1",
            "type": "number"
          },
          {
            "id": "code2",
            "type": "number"
          },
          {
            "id": "code3",
            "type": "number"
          },
          {
            "id": "sub",
            "type": "boolean"
          },
          {
            "id": "insf",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, code1: number, code2: number, code3: number, sub: boolean, insf: boolean",
        "desc": "For the c designated card number code1, code2, code3 monster for the fusion material",
        "id": "AddFusionProcCode3"
      },
      {
        "args": [
          {
            "id": "c",
            "type": "Card"
          },
          {
            "id": "f",
            "type": "function"
          },
          {
            "id": "cc",
            "type": "number"
          },
          {
            "id": "insf",
            "type": "boolean"
          }
        ],
        "argstr": "c: Card, f: function, cc: number, insf: boolean",
        "desc": "For the c designated cc meet the same conditions f monster for the fusion material",
        "id": "AddFusionProcFunRep"
      }
    ]
  }
]
